"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var fs_1 = require("fs");
var html_entities_1 = require("html-entities");
// Minimum length of substrings before checking for matches.
var SUBSTRING_MIN_LENGTH = 5;
var TagInfo = /** @class */ (function () {
    function TagInfo(singular, plural, data) {
        var dataParsed = __spreadArray(["none"], data.map(function (s) { return (0, html_entities_1.decode)(s); }), true);
        this.singular = singular;
        this.plural = plural;
        this.data = dataParsed;
        this.caseMap = new Map(dataParsed.map(function (s) { return [s.toLowerCase(), s]; }));
        var prefixSuffixSetMap = new Map();
        for (var _i = 0, dataParsed_1 = dataParsed; _i < dataParsed_1.length; _i++) {
            var element = dataParsed_1[_i];
            var elementLower = element.toLowerCase();
            var indices = Array.from(new Array(element.length).keys()).slice(SUBSTRING_MIN_LENGTH);
            for (var _a = 0, indices_1 = indices; _a < indices_1.length; _a++) {
                var index = indices_1[_a];
                for (var _b = 0, _c = [
                    elementLower.slice(element.length - index),
                    elementLower.slice(0, index),
                ]; _b < _c.length; _b++) {
                    var substring = _c[_b];
                    var wholeStrings = prefixSuffixSetMap.get(substring);
                    if (!wholeStrings) {
                        wholeStrings = new Set();
                        prefixSuffixSetMap.set(substring, wholeStrings);
                    }
                    wholeStrings.add(element);
                }
            }
        }
        this.prefixSuffixMap = new Map(Array.from(prefixSuffixSetMap.entries()).map(function (_a) {
            var k = _a[0], v = _a[1];
            return [
                k,
                Array.from(v),
            ];
        }));
    }
    return TagInfo;
}());
function getJsonData(filename) {
    return JSON.parse((0, fs_1.readFileSync)("".concat(__dirname, "/../../data/").concat(filename), { encoding: "utf-8" }));
}
var tags = [
    new TagInfo("$class", "$classes", getJsonData("classes.json")),
    new TagInfo("$effect", "$effects", getJsonData("effects.json")),
    new TagInfo("$familiar", "$familiars", getJsonData("familiars.json")),
    new TagInfo("$item", "$items", getJsonData("items.json")),
    new TagInfo("$location", "$locations", getJsonData("locations.json")),
    new TagInfo("$monster", "$monsters", getJsonData("monsters.json")),
    new TagInfo("$skill", "$skills", getJsonData("skills.json")),
    new TagInfo("$path", "$paths", getJsonData("paths.json")),
];
var singularTags = new Map(tags.map(function (tagInfo) { return [tagInfo.singular, tagInfo]; }));
var pluralTags = new Map(tags.map(function (tagInfo) { return [tagInfo.plural, tagInfo]; }));
var rule = {
    meta: {
        docs: {
            description: "Verify enumerated type constants.",
            category: "Fill me in",
            recommended: false,
        },
        fixable: "code",
        hasSuggestions: true,
        schema: [
            {
                type: "object",
                properties: {
                    ignoreCapitalization: {
                        type: "boolean",
                        default: false,
                    },
                    ignoreEntities: {
                        type: "boolean",
                        default: false,
                    },
                    ignoreUnrecognized: {
                        type: "boolean",
                        default: false,
                    },
                },
                additionalProperties: false,
            },
        ],
    },
    create: function (context) {
        var sourceCode = context.sourceCode;
        var options = context.options[0];
        function positionAdd(position, offset) {
            return sourceCode.getLocFromIndex(sourceCode.getIndexFromLoc(position) + offset);
        }
        function splitWithLocation(quasi, pattern) {
            var startOffset = quasi.value.raw.match(/^\s*/)[0].length;
            var endOffset = quasi.value.raw.match(/\s*$/)[0].length;
            // We have to add/subtract one here to deal with the backticks.
            var start = positionAdd(quasi.loc.start, startOffset + 1);
            var end = positionAdd(quasi.loc.end, -endOffset - 1);
            var result = [];
            var match = null;
            var lastMatch = null;
            var sliced = quasi.value.raw.slice(startOffset, quasi.value.raw.length - endOffset);
            while ((match = pattern.exec(sliced)) !== null) {
                result.push([
                    sliced.slice(lastMatch ? lastMatch.index + lastMatch[0].length : 0, match.index),
                    positionAdd(start, lastMatch ? lastMatch.index + lastMatch[0].length : 0),
                    positionAdd(start, match.index),
                ]);
                lastMatch = match;
            }
            result.push([
                sliced.slice(lastMatch ? lastMatch.index + lastMatch[0].length : 0),
                positionAdd(start, lastMatch ? lastMatch.index + lastMatch[0].length : 0),
                end,
            ]);
            return result;
        }
        return {
            TaggedTemplateExpression: function (node) {
                // For now just don't check constants if they contain other template literal expressions
                if (node.quasi.expressions.length > 0)
                    return;
                var tagText = sourceCode.getText(node.tag);
                var singular = singularTags.get(tagText);
                var plural = pluralTags.get(tagText);
                var tagElements = singular !== null && singular !== void 0 ? singular : plural;
                if (!tagElements)
                    return;
                var _loop_1 = function (quasi) {
                    var segments = plural
                        ? splitWithLocation(quasi, /\s*(?<!(?<!\\)\\),\s*/g)
                        : splitWithLocation(quasi, /(?!)/g); // Never matches - don't split.
                    var _loop_2 = function (segmentRaw, start, end) {
                        var range = [
                            sourceCode.getIndexFromLoc(start),
                            sourceCode.getIndexFromLoc(end),
                        ];
                        var segment = segmentRaw.replace(/(?<!\\)\\,/, ",");
                        var lowerCaseSegment = segment.toLowerCase();
                        var properlyCapitalized = tagElements.caseMap.get(lowerCaseSegment);
                        var disambiguations = tagElements.prefixSuffixMap.get(lowerCaseSegment);
                        if (properlyCapitalized === undefined) {
                            var decoded = (0, html_entities_1.decode)(segment);
                            var decodedProperlyCapitalized_1 = tagElements.caseMap.get(decoded.toLowerCase());
                            if (decodedProperlyCapitalized_1 !== undefined) {
                                if (!(options === null || options === void 0 ? void 0 : options.ignoreEntities)) {
                                    context.report({
                                        node: node,
                                        message: "Enumerated value \"".concat(segment, "\" has HTML entities; should be \"").concat(decodedProperlyCapitalized_1, "\"."),
                                        fix: function (fixer) {
                                            return fixer.replaceTextRange(range, decodedProperlyCapitalized_1);
                                        },
                                    });
                                }
                            }
                            else if (disambiguations && disambiguations.length > 1) {
                                var suggestions = disambiguations.map(function (dis) {
                                    return {
                                        desc: "Change enumerated value to ".concat(dis),
                                        fix: function (fixer) {
                                            return fixer.replaceTextRange(range, dis.replace(",", "\\,"));
                                        },
                                    };
                                });
                                context.report({
                                    node: node,
                                    message: "Ambiguous value name \"".concat(segment, "\"."),
                                    suggest: suggestions,
                                });
                            }
                            else if (
                            // Effect names with commas such as $effects`And Your Family, Too` are a degenerate case
                            disambiguations &&
                                disambiguations.length > 0) {
                                context.report({
                                    node: node,
                                    message: "Enumerated value \"".concat(segment, "\" should be \"").concat(disambiguations[0], "\"."),
                                    fix: function (fixer) {
                                        return fixer.replaceTextRange(range, disambiguations[0].replace(",", "\\,"));
                                    },
                                });
                            }
                            else if (!(options === null || options === void 0 ? void 0 : options.ignoreUnrecognized) && segment !== "") {
                                context.report({
                                    node: node,
                                    message: "Unrecognized enumerated value name \"".concat(segment, "\"."),
                                });
                            }
                        }
                        else if (!(options === null || options === void 0 ? void 0 : options.ignoreCapitalization) &&
                            segment !== properlyCapitalized) {
                            context.report({
                                node: node,
                                message: "Enumerated value name \"".concat(segment, "\" should be capitalized \"").concat(properlyCapitalized, "\"."),
                                fix: function (fixer) {
                                    return fixer.replaceTextRange(range, properlyCapitalized);
                                },
                            });
                        }
                    };
                    for (var _b = 0, segments_1 = segments; _b < segments_1.length; _b++) {
                        var _c = segments_1[_b], segmentRaw = _c[0], start = _c[1], end = _c[2];
                        _loop_2(segmentRaw, start, end);
                    }
                    // FIXME: Allow on separate lines.
                    var properlySpaced = segments
                        .map(function (_a) {
                        var segmentRaw = _a[0];
                        return segmentRaw;
                    })
                        .join(", ");
                    if (quasi.value.raw !== properlySpaced) {
                        context.report({
                            node: node,
                            message: "Enumerated value constants should be separated by a comma and space.",
                            fix: function (fixer) {
                                var _a = quasi.range, start = _a[0], end = _a[1];
                                return fixer.replaceTextRange([start + 1, end - 1], properlySpaced);
                            },
                        });
                    }
                };
                for (var _i = 0, _a = node.quasi.quasis; _i < _a.length; _i++) {
                    var quasi = _a[_i];
                    _loop_1(quasi);
                }
            },
        };
    },
};
module.exports = rule;
