import { Class, Effect, Element, Item, Location, Monster, Phylum, Skill, Stat } from "kolmafia";
/**
 * Get the KoL native ID of the macro with name name.
 *
 * @param name Name of the macro
 * @category Combat
 * @returns {number} The macro ID.
 */
export declare function getMacroId(name?: string): number;
type ItemOrName = Item | string;
type PreBALLSPredicate = string | Monster | Monster[] | Effect | Skill | Item | Location | Location[] | Class | Class[] | Stat | Stat[] | Phylum | Phylum[] | Element | Element[] | [Item, Item];
type SkillOrName = Skill | string;
type Constructor<T> = {
    new (): T;
};
export declare class InvalidMacroError extends Error {
}
/**
 * BALLS macro builder for direct submission to KoL.
 * Create a new macro with `new Macro()` and add steps using the instance methods.
 * Uses a fluent interface, so each step returns the object for easy chaining of steps.
 * Each method is also defined as a static method that creates a new Macro with only that step.
 * For example, you can do `Macro.skill('Saucestorm').attack()`.
 */
export declare class Macro {
    static SAVED_MACRO_PROPERTY: string;
    static cachedMacroIds: Map<string, number>;
    static cachedAutoAttacks: Map<string, string>;
    components: string[];
    name: string;
    /**
     * Convert macro to string.
     *
     * @returns BALLS macro
     */
    toString(): string;
    /**
     * Gives your macro a new name to be used when saving an autoattack.
     *
     * @param name The name to be used when saving as an autoattack.
     * @returns The macro in question
     */
    rename(name: string): this;
    /**
     * Creates a new Macro with a name other than the default name.
     *
     * @param name The name to assign this macro.
     * @returns A new Macro with the assigned name.
     */
    static rename<T extends Macro>(this: Constructor<T>, name: string): T;
    /**
     * Save a macro to a Mafia property for use in a consult script.
     */
    save(): void;
    /**
     * Load a saved macro from the Mafia property.
     *
     * @returns Loaded macro text
     */
    static load<T extends Macro>(this: Constructor<T>): T;
    /**
     * Clear the saved macro in the Mafia property.
     */
    static clearSaved(): void;
    /**
     * Statefully add one or several steps to a macro.
     *
     * @param nextSteps The steps to add to the macro.
     * @returns {Macro} This object itself.
     */
    step(...nextSteps: (string | Macro)[]): this;
    /**
     * Statefully add one or several steps to a macro.
     *
     * @param nextSteps The steps to add to the macro.
     * @returns {Macro} This object itself.
     */
    static step<T extends Macro>(this: Constructor<T>, ...nextSteps: (string | Macro)[]): T;
    /**
     * Submit the built macro to KoL. Only works inside combat.
     *
     * @returns Contents of the fight page after macro submission
     */
    submit(): string;
    /**
     * Set this macro as a KoL native autoattack.
     */
    setAutoAttack(): void;
    /**
     * Renames the macro, then sets it as an autoattack.
     *
     * @param name The name to save the macro under as an autoattack.
     */
    setAutoAttackAs(name: string): void;
    /**
     * Clear all cached autoattacks, and delete all stored macros server-side.
     */
    static clearAutoAttackMacros(): void;
    /**
     * Add an "abort" step to this macro.
     *
     * @returns {Macro} This object itself.
     */
    abort(): this;
    /**
     * Create a new macro with an "abort" step.
     *
     * @returns {Macro} This object itself.
     */
    static abort<T extends Macro>(this: Constructor<T>): T;
    /**
     * Adds an "abort" step to this macro, with a warning message to print
     *
     * @param warning The warning message to print
     * @returns  {Macro} This object itself.
     */
    abortWithWarning(warning: string): this;
    /**
     * Create a new macro with an "abort" step to this macro, with a warning message to print
     *
     * @param warning The warning message to print
     * @returns {Macro} This object itself.
     */
    static abortWithWarning<T extends Macro>(this: Constructor<T>, warning: string): T;
    /**
     * Add a "runaway" step to this macro.
     *
     * @returns {Macro} This object itself.
     */
    runaway(): this;
    /**
     * Create a new macro with an "runaway" step.
     *
     * @returns {Macro} This object itself.
     */
    static runaway<T extends Macro>(this: Constructor<T>): T;
    /**
     *
     * @param condition The BALLS condition or a type to make a condition for (Monster, Item, Skill, etc.)
     * @returns {string} The BALLS condition string
     */
    static makeBALLSPredicate(condition: PreBALLSPredicate): string;
    /**
     * Add an "if" statement to this macro.
     *
     * @param condition The BALLS condition for the if statement.
     * @param ifTrue Continuation if the condition is true.
     * @returns {Macro} This object itself.
     */
    if_(condition: PreBALLSPredicate, ifTrue: string | Macro): this;
    /**
     * Create a new macro with an "if" statement.
     *
     * @param condition The BALLS condition for the if statement.
     * @param ifTrue Continuation if the condition is true.
     * @returns {Macro} This object itself.
     */
    static if_<T extends Macro>(this: Constructor<T>, condition: PreBALLSPredicate, ifTrue: string | Macro): T;
    /**
     * Add an "if" statement to this macro, inverting the condition.
     *
     * @param condition The BALLS condition for the if statement.
     * @param ifTrue Continuation if the condition is true.
     * @returns {Macro} This object itself.
     */
    ifNot(condition: PreBALLSPredicate, ifTrue: string | Macro): this;
    /**
     * Create a new macro with an "if" statement, inverting the condition.
     *
     * @param condition The BALLS condition for the if statement.
     * @param ifTrue Continuation if the condition is true.
     * @returns {Macro} This object itself.
     */
    static ifNot<T extends Macro>(this: Constructor<T>, condition: PreBALLSPredicate, ifTrue: string | Macro): T;
    /**
     * Add a "while" statement to this macro.
     *
     * @param condition The BALLS condition for the while statement.
     * @param contents Loop to repeat while the condition is true.
     * @returns {Macro} This object itself.
     */
    while_(condition: PreBALLSPredicate, contents: string | Macro): this;
    /**
     * Create a new macro with a "while" statement.
     *
     * @param condition The BALLS condition for the while statement.
     * @param contents Loop to repeat while the condition is true.
     * @returns {Macro} This object itself.
     */
    static while_<T extends Macro>(this: Constructor<T>, condition: PreBALLSPredicate, contents: string | Macro): T;
    /**
     * Conditionally add a step to a macro based on a condition evaluated at the time of building the macro.
     *
     * @param condition The JS condition.
     * @param ifTrue Continuation to add if the condition is true.
     * @param ifFalse Optional input to turn this into an if...else statement.
     * @returns {Macro} This object itself.
     */
    externalIf(condition: boolean, ifTrue: string | Macro, ifFalse?: string | Macro): this;
    /**
     * Create a new macro with a condition evaluated at the time of building the macro.
     *
     * @param condition The JS condition.
     * @param ifTrue Continuation to add if the condition is true.
     * @param ifFalse Optional input to turn this into an if...else statement.
     * @returns {Macro} This object itself.
     */
    static externalIf<T extends Macro>(this: Constructor<T>, condition: boolean, ifTrue: string | Macro, ifFalse?: string | Macro): T;
    /**
     * Add a repeat step to the macro.
     *
     * @param condition The BALLS condition for the repeat statement, optional.
     * @returns {Macro} This object itself.
     */
    repeat(condition?: PreBALLSPredicate): this;
    /**
     * Add one or more skill cast steps to the macro.
     *
     * @param skills Skills to cast.
     * @returns {Macro} This object itself.
     */
    skill(...skills: SkillOrName[]): this;
    /**
     * Create a new macro with one or more skill cast steps.
     *
     * @param skills Skills to cast.
     * @returns {Macro} This object itself.
     */
    static skill<T extends Macro>(this: Constructor<T>, ...skills: SkillOrName[]): T;
    /**
     * Add one or more skill cast steps to the macro, where each step checks if you have the skill first.
     *
     * @param skills Skills to try casting.
     * @returns {Macro} This object itself.
     */
    trySkill(...skills: SkillOrName[]): this;
    /**
     * Create a new macro with one or more skill cast steps, where each step checks if you have the skill first.
     *
     * @param skills Skills to try casting.
     * @returns {Macro} This object itself.
     */
    static trySkill<T extends Macro>(this: Constructor<T>, ...skills: SkillOrName[]): T;
    /**
     * Add one or more skill-cast-and-repeat steps to the macro, where each step checks if you have the skill first.
     *
     * @param skills Skills to try repeatedly casting.
     * @returns {Macro} This object itself.
     */
    trySkillRepeat(...skills: SkillOrName[]): this;
    /**
     * Create a new macro with one or more skill-cast-and-repeat steps, where each step checks if you have the skill first.
     *
     * @param skills Skills to try repeatedly casting.
     * @returns {Macro} This object itself.
     */
    static trySkillRepeat<T extends Macro>(this: Constructor<T>, ...skills: SkillOrName[]): T;
    /**
     * Add one or more item steps to the macro.
     *
     * @param items Items to use. Pass a tuple [item1, item2] to funksling.
     * @returns {Macro} This object itself.
     */
    item(...items: (ItemOrName | [ItemOrName, ItemOrName])[]): this;
    /**
     * Create a new macro with one or more item steps.
     *
     * @param items Items to use. Pass a tuple [item1, item2] to funksling.
     * @returns {Macro} This object itself.
     */
    static item<T extends Macro>(this: Constructor<T>, ...items: (ItemOrName | [ItemOrName, ItemOrName])[]): T;
    /**
     * Add one or more item steps to the macro, where each step checks to see if you have the item first.
     *
     * @param items Items to try using. Pass a tuple [item1, item2] to funksling.
     * @returns {Macro} This object itself.
     */
    tryItem(...items: (ItemOrName | [ItemOrName, ItemOrName])[]): this;
    /**
     * Create a new macro with one or more item steps, where each step checks to see if you have the item first.
     *
     * @param items Items to try using. Pass a tuple [item1, item2] to funksling.
     * @returns {Macro} This object itself.
     */
    static tryItem<T extends Macro>(this: Constructor<T>, ...items: (ItemOrName | [ItemOrName, ItemOrName])[]): T;
    /**
     * Add an attack step to the macro.
     *
     * @returns {Macro} This object itself.
     */
    attack(): this;
    /**
     * Create a new macro with an attack step.
     *
     * @returns {Macro} This object itself.
     */
    static attack<T extends Macro>(this: Constructor<T>): T;
    /**
     * Create an if_ statement based on what holiday of loathing it currently is. On non-holidays, returns the original macro, unmutated.
     *
     * @param macro The macro to place in the if_ statement
     * @returns This macro with supplied macro wapped in if statement matching holiday wanderers
     */
    ifHolidayWanderer(macro: Macro): this;
    /**
     * Create a new macro starting with an ifHolidayWanderer step.
     *
     * @param macro The macro to place inside the if_ statement
     * @returns New macro with supplied macro wrapped in if statement matching holiday wanderers
     */
    static ifHolidayWanderer<T extends Macro>(this: Constructor<T>, macro: Macro): T;
    /**
     * Create an if_ statement based on what holiday of loathing it currently is. On non-holidays, returns the original macro, with the input macro appended.
     *
     * @param macro The macro to place in the if_ statement.
     * @returns This macro with supplied macro wrapped in if statement matching monsters that are not holiday wanderers
     */
    ifNotHolidayWanderer(macro: Macro): this;
    /**
     * Create a new macro starting with an ifNotHolidayWanderer step.
     *
     * @param macro The macro to place inside the if_ statement
     * @returns New macro with supplied macro wrapped in if statement matching monsters that are not holiday wanderers
     */
    static ifNotHolidayWanderer<T extends Macro>(this: Constructor<T>, macro: Macro): T;
}
/**
 * Adventure in a location and handle all combats with a given macro.
 * To use this function you will need to create a consult script that runs Macro.load().submit() and a CCS that calls that consult script.
 * See examples/consult.ts for an example.
 *
 * @category Combat
 * @param loc Location to adventure in.
 * @param macro Macro to execute.
 */
export declare function adventureMacro(loc: Location, macro: Macro): void;
/**
 * Adventure in a location and handle all combats with a given autoattack and manual macro.
 * To use the nextMacro parameter you will need to create a consult script that runs Macro.load().submit() and a CCS that calls that consult script.
 * See examples/consult.ts for an example.
 *
 * @category Combat
 * @param loc Location to adventure in.
 * @param autoMacro Macro to execute via KoL autoattack.
 * @param nextMacro Macro to execute manually after autoattack completes.
 */
export declare function adventureMacroAuto(loc: Location, autoMacro: Macro, nextMacro?: Macro | null): void;
export declare class StrictMacro extends Macro {
    /**
     * Add one or more skill cast steps to the macro.
     *
     * @param skills Skills to cast.
     * @returns {StrictMacro} This object itself.
     */
    skill(...skills: Skill[]): this;
    /**
     * Create a new macro with one or more skill cast steps.
     *
     * @param skills Skills to cast.
     * @returns {StrictMacro} This object itself.
     */
    static skill<T extends StrictMacro>(this: Constructor<T>, ...skills: Skill[]): T;
    /**
     * Add one or more item steps to the macro.
     *
     * @param items Items to use. Pass a tuple [item1, item2] to funksling.
     * @returns {StrictMacro} This object itself.
     */
    item(...items: (Item | [Item, Item])[]): this;
    /**
     * Create a new macro with one or more item steps.
     *
     * @param items Items to use. Pass a tuple [item1, item2] to funksling.
     * @returns {StrictMacro} This object itself.
     */
    static item<T extends StrictMacro>(this: Constructor<T>, ...items: (Item | [Item, Item])[]): T;
    /**
     * Add one or more skill cast steps to the macro, where each step checks if you have the skill first.
     *
     * @param skills Skills to try casting.
     * @returns {StrictMacro} This object itself.
     */
    trySkill(...skills: Skill[]): this;
    /**
     * Create a new macro with one or more skill cast steps, where each step checks if you have the skill first.
     *
     * @param skills Skills to try casting.
     * @returns {StrictMacro} This object itself.
     */
    static trySkill<T extends StrictMacro>(this: Constructor<T>, ...skills: Skill[]): T;
    /**
     * Add one or more item steps to the macro, where each step checks to see if you have the item first.
     *
     * @param items Items to try using. Pass a tuple [item1, item2] to funksling.
     * @returns {StrictMacro} This object itself.
     */
    tryItem(...items: (Item | [Item, Item])[]): this;
    /**
     * Create a new macro with one or more item steps, where each step checks to see if you have the item first.
     *
     * @param items Items to try using. Pass a tuple [item1, item2] to funksling.
     * @returns {StrictMacro} This object itself.
     */
    static tryItem<T extends StrictMacro>(this: Constructor<T>, ...items: (Item | [Item, Item])[]): T;
    /**
     * Add one or more skill-cast-and-repeat steps to the macro, where each step checks if you have the skill first.
     *
     * @param skills Skills to try repeatedly casting.
     * @returns {StrictMacro} This object itself.
     */
    trySkillRepeat(...skills: Skill[]): this;
    /**
     * Create a new macro with one or more skill-cast-and-repeat steps, where each step checks if you have the skill first.
     *
     * @param skills Skills to try repeatedly casting.
     * @returns {StrictMacro} This object itself.
     */
    static trySkillRepeat<T extends StrictMacro>(this: Constructor<T>, ...skills: Skill[]): T;
}
export {};
