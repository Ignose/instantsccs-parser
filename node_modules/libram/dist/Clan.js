import { decode as decodeEntities } from "html-entities";
import { availableAmount, cliExecute, getClanId, getClanName, getPlayerId, Monster, putStash, refreshStash, retrieveItem, stashAmount, takeStash, visitUrl, xpath, } from "kolmafia";
import { getFoldGroup } from "./lib.js";
import logger from "./logger.js";
import { arrayToCountedMap, countedMapToArray, countedMapToString, notNull, parseNumber, } from "./utils.js";
const clanIdCache = {};
const toPlayerId = (player) => typeof player === "string" ? getPlayerId(player) : player;
const LOG_FAX_PATTERN = /(\d{2}\/\d{2}\/\d{2}, \d{2}:\d{2}(?:AM|PM): )<a [^>]+>([^<]+)<\/a>(?: faxed in a (?<monster>.*?))<br>/;
const WHITELIST_DEGREE_PATTERN = /(?<name>.*?) \(Â°(?<degree>\d+)\)/;
export class Clan {
    id;
    name;
    static _join(id) {
        const result = visitUrl(`showclan.php?recruiter=1&whichclan=${id}&pwd&whichclan=${id}&action=joinclan&apply=Apply+to+this+Clan&confirm=on`);
        if (!result.includes("clanhalltop.gif")) {
            throw new Error("Could not join clan");
        }
        return Clan.get();
    }
    static _withStash(borrowFn, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    returnFn, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callback) {
        const borrowed = borrowFn();
        const map = arrayToCountedMap(borrowed);
        try {
            return callback(borrowed);
        }
        finally {
            if (map.size > 0) {
                const returned = arrayToCountedMap(returnFn(borrowed));
                map.forEach((quantity, item) => {
                    const remaining = quantity - (returned.get(item) || 0);
                    if (remaining > 0) {
                        map.set(item, remaining);
                    }
                    else {
                        map.delete(item);
                    }
                });
                if (map.size > 0) {
                    logger.error(`Failed to return <b>${countedMapToString(map)}</b> to <b>${this.name}</b> stash`);
                }
            }
        }
    }
    /**
     * Join a clan
     *
     * @param clanIdOrName Clan id or name
     * @returns Instance of joined clan
     */
    static join(clanIdOrName) {
        let clanId;
        if (typeof clanIdOrName === "string") {
            const clanName = clanIdOrName.toLowerCase();
            if (clanName === getClanName().toLowerCase()) {
                return Clan.get();
            }
            if (!(clanName in clanIdCache)) {
                const clan = Clan.getWhitelisted().find((c) => c.name.toLowerCase() === clanName);
                if (!clan) {
                    throw new Error("Player is not whitelisted to clan");
                }
                clanIdCache[clanName] = clan.id;
            }
            clanId = clanIdCache[clanName];
        }
        else {
            clanId = clanIdOrName;
            if (clanId === getClanId()) {
                return Clan.get();
            }
        }
        return Clan._join(clanId);
    }
    /**
     * Execute callback as a member of a clan and then restore prior membership
     *
     * @param clanIdOrName Clan id or name
     * @param callback Actions to carry out while member of specified can
     * @returns Return value from callback
     */
    static with(clanIdOrName, callback) {
        const startingClan = Clan.get();
        const clan = Clan.join(clanIdOrName);
        try {
            return callback(clan);
        }
        finally {
            startingClan.join();
        }
    }
    static withStash(clanIdOrName, items, // eslint-disable-line @typescript-eslint/no-explicit-any
    callback) {
        return Clan._withStash(() => Clan.with(clanIdOrName, (clan) => clan.take(items)), (borrowed) => Clan.with(clanIdOrName, (clan) => clan.put(borrowed)), callback);
    }
    /**
     * Get the player's current clan
     *
     * @returns Player's clan
     */
    static get() {
        return new Clan(getClanId(), getClanName());
    }
    /**
     * Get list of clans to which the player is whitelisted
     *
     * @returns List of clans
     */
    static getWhitelisted() {
        const page = visitUrl("clan_signup.php");
        return xpath(page, '//select[@name="whichclan"]//option').map((option) => {
            const validHtml = `<select>${option}</select>`;
            const id = Number.parseInt(xpath(validHtml, "//@value")[0]);
            const name = decodeEntities(xpath(validHtml, "//text()")[0]);
            return new Clan(id, name);
        });
    }
    constructor(id, name) {
        this.id = id;
        this.name = name;
    }
    _check() {
        if (this.id !== getClanId()) {
            throw new Error("You are no longer a member of this clan");
        }
    }
    /**
     * Join clan
     *
     * @returns Joined clan
     */
    join() {
        return Clan.join(this.id);
    }
    /**
     * Check that this clan is the player's current clan
     *
     * @returns Whether this is the current clan
     */
    check() {
        return visitUrl("clan_hall.php").includes(`<b>${this.name}</b>`);
    }
    /**
     * Determine the monster that is currently in the current clan's fax machine if any
     *
     * @returns The current fax monster
     */
    getCurrentFax() {
        this._check();
        const logs = visitUrl("clan_log.php");
        const lastFax = logs.match(LOG_FAX_PATTERN);
        if (!lastFax)
            return null;
        const [, , , monsterName] = lastFax;
        if (!monsterName)
            return null;
        return Monster.get(monsterName);
    }
    /**
     * List available ranks (name, degree and id) from the current clan
     *
     * @returns List of ranks
     */
    getRanks() {
        this._check();
        const page = visitUrl("clan_whitelist.php");
        return xpath(page, '//select[@name="level"]//option')
            .map((option) => {
            const validHtml = `<select>${option}</select>`;
            const match = xpath(validHtml, "//text()")[0].match(WHITELIST_DEGREE_PATTERN);
            const id = xpath(validHtml, "//@value")[0];
            if (!match || !id)
                return null;
            const [, encodedName, degree] = match;
            return {
                name: decodeEntities(encodedName),
                degree: Number.parseInt(degree),
                id: Number.parseInt(id),
            };
        })
            .filter(notNull);
    }
    /**
     * Add a player to the current clan's whitelist.
     * If the player is already in the whitelist this will change their rank or title.
     *
     * @param player Player id or name
     * @param rankName Rank to give the player. If not provided they will be given the lowest rank
     * @param title Title to give the player. If not provided, will be blank
     * @returns Success
     */
    addPlayerToWhitelist(player, rankName, title = "") {
        this._check();
        const playerId = toPlayerId(player);
        const ranks = this.getRanks();
        const rank = rankName
            ? ranks.find((r) => r.name === rankName)
            : ranks.sort((a, b) => a.degree - b.degree)[0];
        if (!rank)
            return false;
        const result = visitUrl(`clan_whitelist.php?action=add&pwd&addwho=${playerId}&level=${rank.id}&title=${title}`);
        return (result.includes("added to whitelist.") ||
            result.includes("That player is already on the whitelist"));
    }
    /**
     * Remove a player from the current clan's whitelist
     *
     * @param player Player id or name
     * @returns Success
     */
    removePlayerFromWhitelist(player) {
        this._check();
        const playerId = toPlayerId(player);
        const result = visitUrl(`clan_whitelist.php?action=updatewl&pwd&who=${playerId}&remove=Remove`);
        return result.includes("Whitelist updated.");
    }
    /**
     * Return the amount of meat in the current clan's coffer
     *
     * @returns Amount of meat
     */
    getMeatInCoffer() {
        this._check();
        const page = visitUrl("clan_stash.php");
        const [, meat] = page.match(/Your <b>Clan Coffer<\/b> contains ([\d,]+) Meat./) || ["0", "0"];
        return parseNumber(meat);
    }
    /**
     * Add the given amount of meat to the current clan's coffer.
     *
     * @param amount Amount of meat to put in coffer
     * @returns Success
     */
    putMeatInCoffer(amount) {
        this._check();
        const result = visitUrl(`clan_stash.php?pwd&action=contribute&howmuch=${amount}`);
        return result.includes("You contributed");
    }
    take(items) {
        this._check();
        const map = arrayToCountedMap(items);
        map.forEach((quantity, item) => {
            let needed = Math.max(0, quantity - availableAmount(item));
            if (needed === 0) {
                return map.set(item, 0);
            }
            const foldGroup = getFoldGroup(item);
            for (const foldable of foldGroup) {
                const quantityToFold = Math.min(needed, availableAmount(foldable));
                for (let i = 0; i < quantityToFold; i++) {
                    cliExecute(`fold ${item.name}`);
                    needed--;
                }
                return map.set(item, needed);
            }
            refreshStash();
            for (const matchingItem of [item, ...foldGroup]) {
                const quantityToTake = Math.min(needed, stashAmount(matchingItem));
                if (quantityToTake === 0)
                    continue;
                // If we can't take from the stash, there's no sense in iterating through the whole fold group
                if (!takeStash(quantityToTake, matchingItem))
                    return;
                if (matchingItem === item) {
                    needed -= quantityToTake;
                }
                else {
                    for (let i = 0; i < quantityToTake; i++) {
                        cliExecute(`fold ${matchingItem.name}`);
                        needed--;
                    }
                }
            }
        });
        return Array.isArray(items) ? countedMapToArray(map) : map;
    }
    put(items) {
        this._check();
        const map = arrayToCountedMap(items);
        if (!this.check())
            throw new Error(`Wanted to return ${countedMapToString(map)} to ${this.name} but KoLmafia's clan data is out of sync`);
        map.forEach((quantity, item) => {
            retrieveItem(quantity, item);
            const returned = Math.min(quantity, availableAmount(item));
            putStash(returned, item);
            map.set(item, quantity - returned);
        });
        return Array.isArray(items) ? countedMapToArray(map) : map;
    }
    withStash(items, callback) {
        this._check();
        const map = arrayToCountedMap(items);
        return Clan._withStash(() => this.take(map), (borrowed) => this.put(borrowed), callback);
    }
}
