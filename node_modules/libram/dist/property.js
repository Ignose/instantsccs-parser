import { Bounty, Class, Coinmaster, Effect, Element, Familiar, getProperty, Item, Location, Monster, Phylum, propertyExists, removeProperty, Servant, setProperty, Skill, Slot, Stat, Thrall, toBounty, toClass, toCoinmaster, toEffect, toElement, toFamiliar, toItem, toLocation, toMonster, toPhylum, toServant, toSkill, toSlot, toStat, toThrall, } from "kolmafia";
import { familiarNumericProperties, itemNumericProperties, monsterNumericProperties, } from "./propertyTypes.js";
import { isBooleanProperty, isFamiliarProperty, isItemProperty, isLocationProperty, isMonsterProperty, isNumericOrStringProperty, isNumericProperty, isPhylumProperty, isStatProperty, isStringProperty, } from "./propertyTyping.js";
const createPropertyGetter = (transform) => (property, default_) => {
    const value = getProperty(property);
    if (default_ !== undefined && value === "") {
        return default_;
    }
    return transform(value, property);
};
function createMafiaClassPropertyGetter(Type, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
toType, numericPropertyNames = []) {
    return createPropertyGetter((value, property) => {
        if (value === "")
            return null;
        const v = numericPropertyNames.includes(property)
            ? value.match(/^[0-9]+$/)
                ? toType(parseInt(value))
                : null
            : toType(value);
        return v === Type.none ? null : v;
    });
}
export const getString = createPropertyGetter((value) => value);
export const getCommaSeparated = createPropertyGetter((value) => value.split(/, ?/));
export const getBoolean = createPropertyGetter((value) => value === "true");
export const getNumber = createPropertyGetter((value) => Number(value));
export const getBounty = createMafiaClassPropertyGetter(Bounty, toBounty);
export const getClass = createMafiaClassPropertyGetter(Class, toClass);
export const getCoinmaster = createMafiaClassPropertyGetter(Coinmaster, toCoinmaster);
export const getEffect = createMafiaClassPropertyGetter(Effect, toEffect);
export const getElement = createMafiaClassPropertyGetter(Element, toElement);
export const getFamiliar = createMafiaClassPropertyGetter(Familiar, toFamiliar, familiarNumericProperties);
export const getItem = createMafiaClassPropertyGetter(Item, toItem, itemNumericProperties);
export const getLocation = createMafiaClassPropertyGetter(Location, toLocation);
export const getMonster = createMafiaClassPropertyGetter(Monster, toMonster, monsterNumericProperties);
export const getPhylum = createMafiaClassPropertyGetter(Phylum, toPhylum);
export const getServant = createMafiaClassPropertyGetter(Servant, toServant);
export const getSkill = createMafiaClassPropertyGetter(Skill, toSkill);
export const getSlot = createMafiaClassPropertyGetter(Slot, toSlot);
export const getStat = createMafiaClassPropertyGetter(Stat, toStat);
export const getThrall = createMafiaClassPropertyGetter(Thrall, toThrall);
/**
 * Gets the value of a mafia property, either built in or custom
 *
 * @param property Name of the property
 * @param _default Default value for the property to take if not set
 * @returns Value of the mafia property
 */
export function get(property, _default) {
    const value = getString(property);
    // Handle known properties.
    if (isBooleanProperty(property)) {
        return getBoolean(property, _default) ?? false;
    }
    else if (isNumericProperty(property)) {
        return getNumber(property, _default) ?? 0;
    }
    else if (isNumericOrStringProperty(property)) {
        return value.match(/^\d+$/) ? parseInt(value) : value;
    }
    else if (isLocationProperty(property)) {
        return getLocation(property, _default);
    }
    else if (isMonsterProperty(property)) {
        return getMonster(property, _default);
    }
    else if (isFamiliarProperty(property)) {
        return getFamiliar(property, _default);
    }
    else if (isStatProperty(property)) {
        return getStat(property, _default);
    }
    else if (isPhylumProperty(property)) {
        return getPhylum(property, _default);
    }
    else if (isItemProperty(property)) {
        return getItem(property, _default);
    }
    else if (isStringProperty(property)) {
        return value === "" && _default !== undefined ? _default : value;
    }
    // Not a KnownProperty from here on out.
    if (_default instanceof Location) {
        return getLocation(property, _default);
    }
    else if (_default instanceof Monster) {
        return getMonster(property, _default);
    }
    else if (_default instanceof Familiar) {
        return getFamiliar(property, _default);
    }
    else if (_default instanceof Stat) {
        return getStat(property, _default);
    }
    else if (_default instanceof Phylum) {
        return getPhylum(property, _default);
    }
    else if (_default instanceof Item) {
        return getItem(property, _default);
    }
    else if (typeof _default === "boolean") {
        return value === "true" ? true : value === "false" ? false : _default;
    }
    else if (typeof _default === "number") {
        return value === "" ? _default : parseInt(value);
    }
    else if (value === "") {
        return _default === undefined ? "" : _default;
    }
    else {
        return value;
    }
}
/**
 * Sets the value of a mafia property, either built in or custom
 *
 * @param property Name of the property
 * @param value Value to give the property
 * @returns Value that was set
 */
export function set(property, value) {
    const stringValue = value === null ? "" : value.toString();
    setProperty(property, stringValue);
    return value;
}
/**
 * Increment a property
 *
 * @param property Numeric property to increment
 * @param delta Number by which to increment
 * @param max Maximum value to set
 * @returns New value
 */
export function increment(property, delta = 1, max = Infinity) {
    const value = get(property);
    if (!isNumericProperty(property))
        return value;
    const nextValue = Math.min(max, value + delta);
    return set(property, nextValue);
}
/**
 * Decrement a property
 *
 * @param property Numeric property to decrement
 * @param delta Number by which to decrement
 * @param min Maximum value to set
 * @returns New value
 */
export function decrement(property, delta = 1, min = Infinity) {
    const value = get(property);
    if (!isNumericProperty(property))
        return value;
    const nextValue = Math.max(min, value - delta);
    return set(property, nextValue);
}
/**
 * Sets the value of a set of mafia properties
 *
 * @param properties Set of properties
 */
export function setProperties(properties) {
    for (const [prop, value] of Object.entries(properties)) {
        set(prop, value);
    }
}
/**
 * Carries out a callback during which a set of properties will be set as supplied
 *
 * @param properties Properties to set during callback
 * @param callback Callback to execute with set properties
 * @returns Return value of the supplied callback
 */
export function withProperties(properties, callback) {
    const propertiesBackup = Object.fromEntries(Object.entries(properties).map(([prop]) => [prop, get(prop)]));
    setProperties(properties);
    try {
        return callback();
    }
    finally {
        setProperties(propertiesBackup);
    }
}
/**
 * Carries out a callback during which a property will be set as supplied
 *
 * @param property Property to set during callback
 * @param value Value to set property during callback
 * @param callback Callback to execute with set properties
 * @returns Return value of the supplied callback
 */
export function withProperty(property, value, callback) {
    return withProperties({ [property]: value }, callback);
}
/**
 * Carries out a callback during which a set of choices will be handled as supplied
 *
 * @param choices Choices to set during callback
 * @param callback Callback to execute with set choices
 * @returns Return value of the supplied callback
 */
export function withChoices(choices, callback) {
    const properties = Object.fromEntries(Object.entries(choices).map(([choice, option]) => [
        `choiceAdventure${choice}`,
        option,
    ]));
    return withProperties(properties, callback);
}
/**
 * Carries out a callback during which a choice will be handled as supplied
 *
 * @param choice Choice to set during callback
 * @param value How to handle choice during callback
 * @param callback Callback to execute with set properties
 * @returns Return value of the supplied callback
 */
export function withChoice(choice, value, callback) {
    return withChoices({ [choice]: value }, callback);
}
export class PropertiesManager {
    static EMPTY_PREFERENCE = Symbol("empty preference");
    properties = {};
    get storedValues() {
        return this.properties;
    }
    /**
     * Sets a collection of properties to the given values, storing the old values.
     *
     * @param propertiesToSet A Properties object, keyed by property name.
     */
    set(propertiesToSet) {
        for (const [propertyName, propertyValue] of Object.entries(propertiesToSet)) {
            if (!(propertyName in this.properties)) {
                this.properties[propertyName] = propertyExists(propertyName)
                    ? get(propertyName)
                    : PropertiesManager.EMPTY_PREFERENCE;
            }
            set(propertyName, propertyValue);
        }
    }
    /**
     * Sets a collection of choice adventure properties to the given values, storing the old values.
     *
     * @param choicesToSet An object keyed by choice adventure number.
     */
    setChoices(choicesToSet) {
        this.set(Object.fromEntries(Object.entries(choicesToSet).map(([choiceNumber, choiceValue]) => [
            `choiceAdventure${choiceNumber}`,
            choiceValue,
        ])));
    }
    /**
     * Sets a single choice adventure property to the given value, storing the old value.
     *
     * @param choiceToSet The number of the choice adventure to set the property for.
     * @param value The value to assign to that choice adventure.
     */
    setChoice(choiceToSet, value) {
        this.setChoices({ [choiceToSet]: value });
    }
    /**
     * Resets the given properties to their original stored value. Does not delete entries from the manager.
     *
     * @param properties Collection of properties to reset.
     */
    reset(...properties) {
        for (const property of properties) {
            if (!(property in this.properties))
                continue;
            const value = this.properties[property];
            if (value === PropertiesManager.EMPTY_PREFERENCE) {
                removeProperty(property);
            }
            else {
                set(property, value);
            }
        }
    }
    /**
     * Iterates over all stored values, setting each property back to its original stored value. Does not delete entries from the manager.
     */
    resetAll() {
        this.reset(...Object.keys(this.properties));
    }
    /**
     * Stops storing the original values of inputted properties.
     *
     * @param properties Properties for the manager to forget.
     */
    clear(...properties) {
        for (const property of properties) {
            if (this.properties[property]) {
                delete this.properties[property];
            }
        }
    }
    /**
     * Clears all properties.
     */
    clearAll() {
        this.properties = {};
    }
    /**
     * Increases a numeric property to the given value if necessary.
     *
     * @param property The numeric property we want to potentially raise.
     * @param value The minimum value we want that property to have.
     * @returns Whether we needed to change the property.
     */
    setMinimumValue(property, value) {
        if (get(property, 0) < value) {
            this.set({ [property]: value });
            return true;
        }
        return false;
    }
    /**
     * Decrease a numeric property to the given value if necessary.
     *
     * @param property The numeric property we want to potentially lower.
     * @param value The maximum value we want that property to have.
     * @returns Whether we needed to change the property.
     */
    setMaximumValue(property, value) {
        if (get(property, 0) > value) {
            this.set({ [property]: value });
            return true;
        }
        return false;
    }
    /**
     * Creates a new PropertiesManager with identical stored values to this one.
     *
     * @returns A new PropertiesManager, with identical stored values to this one.
     */
    clone() {
        const newGuy = new PropertiesManager();
        newGuy.properties = this.storedValues;
        return newGuy;
    }
    /**
     * Clamps a numeric property, modulating it up or down to fit within a specified range
     *
     * @param property The numeric property to clamp
     * @param min The lower bound for what we want the property to be allowed to be.
     * @param max The upper bound for what we want the property to be allowed to be.
     * @returns Whether we ended up changing the property or not.
     */
    clamp(property, min, max) {
        if (max < min)
            return false;
        const start = get(property);
        this.setMinimumValue(property, min);
        this.setMaximumValue(property, max);
        return start !== get(property);
    }
    /**
     * Determines whether this PropertiesManager has identical stored values to another.
     *
     * @param other The PropertiesManager to compare to this one.
     * @returns Whether their StoredValues are identical.
     */
    equals(other) {
        const thisProps = Object.entries(this.storedValues);
        const otherProps = new Map(Object.entries(other.storedValues));
        if (thisProps.length !== otherProps.size)
            return false;
        for (const [propertyName, propertyValue] of thisProps) {
            if (otherProps.get(propertyName) === propertyValue)
                return false;
        }
        return true;
    }
    /**
     * Merges a PropertiesManager onto this one, letting the input win in the event that both PropertiesManagers have a value stored.
     *
     * @param other The PropertiesManager to be merged onto this one.
     * @returns A new PropertiesManager with stored values from both its parents.
     */
    merge(other) {
        const newGuy = new PropertiesManager();
        newGuy.properties = { ...this.properties, ...other.properties };
        return newGuy;
    }
    /**
     * Merges an arbitrary collection of PropertiesManagers, letting the rightmost PropertiesManager win in the event of verlap.
     *
     * @param mergees The PropertiesManagers to merge together.
     * @returns A PropertiesManager that is just an amalgam of all the constituents.
     */
    static merge(...mergees) {
        if (mergees.length === 0)
            return new PropertiesManager();
        return mergees.reduce((a, b) => a.merge(b));
    }
}
