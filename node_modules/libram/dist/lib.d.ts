/** @module GeneralLibrary */
import { Effect, Element, Familiar, Item, Location, Monster, runCombat, Servant, Skill, Slot, Stat, Thrall, Coinmaster, MafiaClass } from "kolmafia";
import { ValueOf } from "./utils.js";
import { StringProperty } from "./propertyTypes.js";
/**
 * Determines the current maximum Accordion Thief songs the player can have in their head
 *
 * @category General
 * @returns Maximum number of songs for player
 */
export declare function getSongLimit(): number;
/**
 * Determine whether the Skill or Effect provided is an Accordion Thief song
 *
 * @category General
 * @param skillOrEffect The Skill or Effect
 * @returns Whether it's a song
 */
export declare function isSong(skillOrEffect: Skill | Effect): boolean;
/**
 * List all active Effects
 *
 * @category General
 * @returns List of Effects
 */
export declare function getActiveEffects(): Effect[];
/**
 * List currently active Accordion Thief songs
 *
 * @category General
 * @returns List of song Effects
 */
export declare function getActiveSongs(): Effect[];
/**
 * List number of active Accordion Thief songs
 *
 * @category General
 * @returns Number of songs
 */
export declare function getSongCount(): number;
/**
 * Determine whether player can remember another Accordion Thief song
 *
 * @category General
 * @param quantity Number of songs to test the space for
 * @returns Whether player can remember another song
 */
export declare function canRememberSong(quantity?: number): boolean;
/**
 * Determine the locations in which the given monster can be encountered naturally
 *
 * @category General
 * @param monster Monster to find
 * @returns Locations for monster
 */
export declare function getMonsterLocations(monster: Monster): Location[];
/**
 * Determine the player's remaining liver space
 *
 * @category General
 * @returns Remaining liver space
 */
export declare function getRemainingLiver(): number;
/**
 * Determine the player's remaining stomach space
 *
 * @category General
 * @returns Remaining stomach space
 */
export declare function getRemainingStomach(): number;
/**
 * Determine the player's remaining spleen space
 *
 * @category General
 * @returns Remaining spleen space
 */
export declare function getRemainingSpleen(): number;
/**
 * Determine whether the player "has" any entity which one could feasibly "have".
 *
 * @category General
 * @param thing Thing to check
 * @param quantity Minimum quantity the player must have to pass
 * @returns Whether the player meets the requirements of owning the supplied thing
 */
export declare function have(thing: Effect | Familiar | Item | Servant | Skill | Thrall, quantity?: number): boolean;
/**
 * Determine whether a given item is in the player's campground
 *
 * @category General
 * @param item The Item KoLmafia uses to represent the campground item
 * @returns Whether the item is in the campground
 */
export declare function haveInCampground(item: Item): boolean;
export declare enum Wanderer {
    Digitize = "Digitize Monster",
    Enamorang = "Enamorang Monster",
    Familiar = "Familiar",
    Holiday = "Holiday Monster",
    Kramco = "Kramco",
    Nemesis = "Nemesis Assassin",
    Portscan = "portscan.edu",
    Romantic = "Romantic Monster",
    Vote = "Vote Monster"
}
/**
 * Determine whether the player has the specified counter
 *
 * @param counterName Name of the counter
 * @param minTurns Minimum turns the counter is set to
 * @param maxTurns Maximum turns the counter is set to
 * @category General
 * @returns Whether player has the counter
 */
export declare function haveCounter(counterName: string, minTurns?: number, maxTurns?: number): boolean;
/**
 * Determine whether the player has the specified wanderer's counter
 *
 * @param wanderer Wanderer to check
 * @category Wanderers
 * @returns Whether player has the wanderer counter
 */
export declare function haveWandererCounter(wanderer: Wanderer): boolean;
/**
 * Determine whether the player will encounter a vote wanderer on the next turn,
 * providing an "I Voted!" sticker is equipped.
 *
 * @category Wanderers
 * @returns Whether the vote wanderer is due
 */
export declare function isVoteWandererNow(): boolean;
/**
 * Tells us whether we can expect a given wanderer now. Behaves differently
 * for different types of wanderer.
 *
 * - For deterministic wanderers, return whether the player will encounter
 *   the queried wanderer on the next turn
 *
 * - For variable wanderers (window), return whether the player is within
 *   an encounter window for the queried wanderer
 *
 * - For variable wanderers (chance per turn), returns true unless the player
 *   has exhausted the number of wanderers possible
 *
 * @category Wanderers
 * @param wanderer Wanderer to check
 * @returns Whether the wanderer is due
 */
export declare function isWandererNow(wanderer: Wanderer): boolean;
/**
 * Determines the chance the player will encounter a sausage goblin on the
 * next turn, providing the Kramco Sausage-o-Matic is equipped.
 *
 * @category Wanderers
 * @returns Chance that the sausage goblin is due (as a number between 0 and 1)
 */
export declare function getKramcoWandererChance(): number;
/**
 * Determines the chance the player will encounter an Artistic Goth Kid or
 * Mini-Hipster wanderer on the next turn, providing a familiar is equipped.
 *
 * NOTE: You must complete one combat with the Artistic Goth Kid before you
 * can encounter any wanderers. Consequently,Æ’ the first combat with the
 * Artist Goth Kid is effectively 0% chance to encounter a wanderer.
 *
 * @category Wanderers
 * @returns Chance that the familiar wanderer is due (as a number between 0 and 1)
 */
export declare function getFamiliarWandererChance(): number;
/**
 * Determines the chance the player will encounter the specified wanderer
 * on the next turn.
 *
 * @category Wanderers
 * @param wanderer Wanderer to check
 * @returns Chance that the specified wanderer is due (as a number between 0 and 1)
 */
export declare function getWandererChance(wanderer: Wanderer): number;
/**
 * Determines whether the player's current familiar is equal to the one supplied
 *
 * @category General
 * @param familiar Familiar to check
 * @returns Whether it is the player's current familiar
 */
export declare function isCurrentFamiliar(familiar: Familiar): boolean;
/**
 * Determines the fold group (if any) of which the given item is a part
 *
 * @category General
 * @param item Item that is part of the required fold group
 * @param cache Whether to query the fold group cache
 * @returns List of items in the fold group
 */
export declare function getFoldGroup(item: Item, cache?: boolean): Item[];
/**
 * Determines the zap group (if any) of which the given item is a part
 *
 * @category General
 * @param item Item that is part of the required zap group
 * @returns List of items in the zap group
 */
export declare function getZapGroup(item: Item): Item[];
/**
 * Translate mafia's multi-dimensional array prefs into a multi-dimensional array
 * @param prop The name of the mafia string property to process
 * @param outerDelimiter The "outer" delimiter, which separates tuples from eachother
 * @param innerDelimiter The "inner" delimieter, which separates the elements of tuples from eachother
 * @param mappers An array of string => whatever mapping functions that turn this into the actual objects we want
 * @returns An array of typed tuples, based on the given inputs
 */
export declare function multiSplit<T extends any[]>(prop: StringProperty, outerDelimiter: string, innerDelimiter: string, mappers: {
    [K in keyof T]: (str: string) => T[K];
}): T[];
/**
 * Get a map of banished monsters keyed by what banished them
 *
 * @category General
 * @returns Map of banished monsters
 */
export declare function getBanishedMonsters(): Map<Item | Skill, Monster>;
/**
 * Determines whether the item is usable
 *
 * This function will be an ongoing work in progress
 *
 * @param item Item to check
 * @returns Whether item is usable
 */
export declare function canUse(item: Item): boolean;
/**
 * Turn KoLmafia `none`s to JavaScript `null`s
 *
 * @param thing Thing that can have a mafia "none" value
 * @returns The thing specified or `null`
 */
export declare function noneToNull<T extends MafiaClass>(thing: T): T | null;
/**
 * Parse the sort of range that KoLmafia encodes as a string
 * @param range KoLmafia-style range string
 * @returns Tuple of integers representing range
 */
export declare function getRange(range: string): [number, number];
/**
 * Determine the average value from the sort of range that KoLmafia encodes as a string
 *
 * @param range KoLmafia-style range string
 * @returns Average value for range
 */
export declare function getAverage(range: string): number;
/**
 * Deternube tge average adventures expected from consuming an Item
 *
 * If item is not a consumable, will just return "0".
 *
 * @param item Consumable item
 * @returns Average aventures from consumable
 */
export declare function getAverageAdventures(item: Item): number;
/**
 * Remove an effect
 *
 * @category General
 * @param effect Effect to remove
 * @returns Success
 */
export declare function uneffect(effect: Effect): boolean;
/**
 * Get the player id from a player name
 * @param name the name of the player
 * @param onMissing Pass "throw" or omit to throw an error if the player is not found
 * @returns the player id, or throws if no such player exists
 */
export declare function getPlayerIdFromName(name: string, onMissing?: "throw"): number;
/**
 * Get the player id from a player name (if it exists)
 * @param name the name of the player
 * @param onMissing Pass "throw" to throw an error if the player is not found, or "return-null" to return null
 * @returns the player id if the player exists, or handles according to onMissing
 */
export declare function getPlayerIdFromName(name: string, onMissing: "throw" | "return-null"): number | null;
/**
 * Get the player id from a player name
 * @param id the id of the player
 * @param onMissing Pass "throw" or omit to throw an error if the player is not found
 * @returns the player id, or throws if no such player exists
 */
export declare function getPlayerNameFromId(id: number, onMissing?: "throw"): string;
/**
 * Get the player id from a player name (if it exists)
 * @param id the id of the player
 * @param onMissing Pass "throw" to throw an error if the player is not found, or "return-null" to return null * @returns the player id, or null if no such player exists
 * @returns the player id if the player exists, or handles according to onMissing
 */
export declare function getPlayerNameFromId(id: number, onMissing: "throw" | "return-null"): string | null;
export type Player = {
    name: string;
    id: number;
};
/**
 * Get both the name and id of a player from either their name or id
 *
 * @param idOrName Id or name of player
 * @param onMissing Pass "throw" or omit to throw an error if the player is not found
 * @returns Object containing id and name of player
 * @throws {Error} Throws an error if the player is not found
 */
export declare function getPlayerFromIdOrName(idOrName: number | string, onMissing?: "throw"): Player;
/**
 * Get both the name and id of a player from either their name or id
 *
 * @param idOrName Id or name of player
 * @param onMissing Pass "return-null" to return null if the player is not found
 * @returns Object containing id and name of player if it exists, or handles according to onMissing
 */
export declare function getPlayerFromIdOrName(idOrName: number | string, onMissing: "throw" | "return-null"): Player | null;
/**
 * Determine the step as a number for a given quest property.
 *
 * @param questName Name of quest property to check.
 * @returns Quest step
 */
export declare function questStep(questName: string): number;
export declare class EnsureError extends Error {
    constructor(cause: Item | Familiar | Effect, reason?: string);
}
/**
 * Tries to get an effect using the default method
 *
 * @param ef effect to try to get
 * @param turns turns to aim for; default of 1
 * @throws {EnsureError} Throws an error if the effect cannot be guaranteed
 */
export declare function ensureEffect(ef: Effect, turns?: number): void;
/**
 * Determiens the average value (based on mallprice and autosell) of a collection of items
 *
 * @param items items whose value you care about
 * @returns Average value of items
 */
export declare function getSaleValue(...items: Item[]): number;
export declare const Environment: {
    readonly Outdoor: "outdoor";
    readonly Indoor: "indoor";
    readonly Underground: "underground";
    readonly Underwater: "underwater";
};
export type EnvironmentType = ValueOf<typeof Environment>;
/**
 * Determines the weight-coefficient of any leprechaunning that this familiar may find itself doing
 * Assumes the familiar is nude and thus fails for hatrack & pantsrack
 * For the Mutant Cactus Bud, returns the efficacy-multiplier instead
 *
 * @param familiar The familiar whose leprechaun multiplier you're interested in
 * @returns Weight-coefficient
 */
export declare function findLeprechaunMultiplier(familiar: Familiar): number;
/**
 * Determines the weight-coefficient of any baby gravy fairying that this familiar may find itself doing
 * Assumes the familiar is nude and thus fails for hatrack & pantsrack
 * For the Mutant Fire Ant, returns the efficacy-multiplier instead
 *
 * @param familiar The familiar whose fairy multiplier you're interested in
 * @returns Weight-coefficient
 */
export declare function findFairyMultiplier(familiar: Familiar): number;
export declare const holidayWanderers: Map<string, Monster[]>;
/**
 * Get today's holiday wanderers
 *
 * @returns List of holiday wanderer Monsters
 */
export declare function getTodaysHolidayWanderers(): Monster[];
/**
 * Determines whether or not we can safely call visitUrl(), based on whether we're in a fight, multi-fight, choice, etc
 *
 * @returns Whether urls can be safely visited
 */
export declare function canVisitUrl(): boolean;
/**
 * Calculate damage taken from a specific element after factoring in resistance
 *
 * @param baseDamage Base damage
 * @param element Element
 * @returns damage after factoring in resistances
 */
export declare function damageTakenByElement(baseDamage: number, element: Element): number;
/**
 * Get information from telescope
 *
 * @returns An object with all information the telescope gives you about the sorceress's contests and maze
 */
export declare function telescope(): {
    statContest?: Stat;
    elementContest?: Element;
    hedge1?: Element;
    hedge2?: Element;
    hedge3?: Element;
};
/**
 * Visit the desc_x.php page for a given thing
 *
 * @param thing Thing to examine
 * @returns Contents of desc_x.php page
 */
export declare function examine(thing: Item | Familiar | Effect | Skill): string;
/**
 * Picks an option based on your primestat
 *
 * @param options An object keyed by stat; it must either contain all stats, or have a `default` parameter.
 * @param alternateSource An optional alternate way of determining which Stat to choose by.
 * @returns The option corresponding to your primestat.
 */
export declare const byStat: <S>(options: import("./utils.js").Switch<import("kolmafia").StatType, S>, alternateSource?: import("kolmafia").StatType | ((...args: never[]) => import("kolmafia").StatType) | undefined) => S;
/**
 * Picks an option based on your player class
 *
 * @param options An object keyed by player class; it must either contain all classes, or have a `default` parameter.
 * @param alternateSource An optional anternate way of determining which Class to choose by.
 * @returns The option corresponding to your player class.
 */
export declare const byClass: <S>(options: import("./utils.js").Switch<import("kolmafia").ClassType, S>, alternateSource?: import("kolmafia").ClassType | ((...args: never[]) => import("kolmafia").ClassType) | undefined) => S;
/**
 * Use an item with visitUrl instead of `use`; this is sometimes useful
 *
 * @param item The item you want to use
 * @returns The html of the resulting page
 */
export declare function directlyUse(item: Item): string;
/**
 * Unequip all instances of a given equipped item
 *
 * @param item The item in question
 * @returns Whether we succeeded completely--`false` if we unequip some but not all instances of the item.
 */
export declare function unequip(item: Item): boolean;
/**
 * Empty a given slot.
 *
 * @param slot The slot in question
 * @returns Whether we successfully emptied the slot
 */
export declare function unequip(slot: Slot): boolean;
/**
 * @returns a Date object corresponding to the current in-game day, at midnight
 */
export declare function gameDay(): Date;
/**
 * @param [type="all"] the type of crafting to check for free crafts
 * @returns the number of free crafts available of that type
 */
export declare function freeCrafts(type?: "food" | "smith" | "booze" | "all"): number;
export declare const realmTypes: readonly ["spooky", "stench", "hot", "cold", "sleaze", "fantasy", "pirate", "cyber"];
export type RealmType = (typeof realmTypes)[number];
/**
 * @param identifier which realm to check for
 * @returns if that realm is available
 */
export declare function realmAvailable(identifier: RealmType): boolean;
/**
 * Compute the currently available Lucky Gold Ring Currencies
 * @param realm the realm type to consider
 * @returns The currency for the given zone
 */
export declare function realmCurrency(realm: RealmType): Item | null;
/**
 * Compute which Lucky Gold Ring currencies are currently available
 * @returns a list of currently available currencies
 */
export declare function lgrCurrencies(): Item[];
declare const ACCOUNT_COMBAT_FLAGS: readonly ["aabosses", "wowbar", "bothcombatinterf", "compactmanuel", "eternalmrj", "disablelovebugs", "boringdarts"];
/**
 * Different flags you can set on your account for how to handle combat:
 * aabosses refers to the flag that lets autoattack trigger against special monsters
 * wowbar refers to the flag to use the Combat Action Bar
 * bothcombatinterf refers to the flag to use both the CAB
 * compactmanuel refers to the flag to display monster manuel data horizontally
 * eternalmrg refers to the flag to enable endless factoid delight
 * disablelovebugs disables love bugs
 * boringdarts avoid rendering the dartboard in combat
 */
export type AccountCombatFlag = (typeof ACCOUNT_COMBAT_FLAGS)[number];
/**
 * Get the current value of all of your account's combat setting flags
 * @param flags An array of the flags you want to get, defaults to all of them
 * @returns An array of objects that contain the flags and their values as booleans
 */
export declare function getCombatFlags(flags?: AccountCombatFlag[]): {
    flag: AccountCombatFlag;
    value: boolean;
}[];
/**
 * Sets the given combat setting flags on your account
 *
 * @param flags A spread array of objects that contain a flag and its desired value; these look like the return value of `getCombatFlags`
 * @returns the result of the associated `visitUrl` call
 */
export declare function setCombatFlags(...flags: {
    flag: AccountCombatFlag;
    value: boolean;
}[]): string;
/**
 * Perform a given action with certain combat setting flags set, returning them to their initial values if possible
 *
 * @param action The action you want to do with the given combat setting flags
 * @param flags A spread array of objects that contain a combat setting flag and its desired value; these look like the return value of `getCombatFlags`
 * @returns The result of the action
 */
export declare function withCombatFlags<T>(action: () => T, ...flags: {
    flag: AccountCombatFlag;
    value: boolean;
}[]): T;
/**
 * Determines whether you currently have an effect intrinsically
 * @param effect The effect in question
 * @returns Whether you have that effect as an intrinsic. Alternately you could just have over 2147483647 turns of that effect, but that seems unlikely.
 */
export declare function haveIntrinsic(effect: Effect): boolean;
/**
 * Extracts a map of gained items from a string, for example from the result
 * of a combat.
 *
 * NOTE: Make sure you trust the source of that text.
 *
 * @param text The text to extract items from
 * @returns A map of items and their quantities
 */
export declare function extractItems(text: string): Map<Item, number>;
export type CombatParams = Parameters<typeof runCombat>;
/**
 * Calculate & return the scaling rate of a monster--`0` for non-scalers.
 * @param monster The monster to check
 * @returns The current scaling rate of the monster, based on your current in-game state
 */
export declare const getScalingRate: (monster: Monster) => number;
/**
 * Calculate & return the scaling cap of a monster--`0` for non-scalers.
 * @param monster The monster to check
 * @returns The current scaling cap of the monster, based on your current in-game state
 */
export declare const getScalingCap: (monster: Monster) => number;
/**
 * Wrap a specified action in mafia's `batchOpen` and `batchClose`
 *
 * @param action Action to perform while using mafia's batching feature
 * @returns The return value of the action
 */
export declare function withBatch<T>(action: () => T): T;
export declare const bulkAutosell: (items: Map<Item, number>) => boolean;
export declare const bulkPutCloset: (items: Map<Item, number>) => boolean;
export declare const bulkPutDisplay: (items: Map<Item, number>) => boolean;
export declare const bulkPutStash: (items: Map<Item, number>) => boolean;
export declare const bulkTakeCloset: (items: Map<Item, number>) => boolean;
export declare const bulkTakeDisplay: (items: Map<Item, number>) => boolean;
export declare const bulkTakeShop: (items: Map<Item, number>) => boolean;
export declare const bulkTakeStash: (items: Map<Item, number>) => boolean;
export declare const bulkTakeStorage: (items: Map<Item, number>) => boolean;
export declare const bulkPutShop: (items: Map<Item, {
    quantity?: number;
    limit?: number;
    price: number;
}>) => boolean;
export declare const bulkSell: (coinmaster: Coinmaster, items: Map<Item, number>) => boolean;
export declare const bulkRepriceShop: (items: Map<Item, {
    quantity?: number;
    limit?: number;
    price: number;
}>) => boolean;
/**
 * Calculate the total weight of a given familiar, including soup & modifiers
 * @param familiar The familiar to use--defaults to your current one
 * @param considerAdjustment Whether to include your `weightAdjustment` in the calculation
 * @returns The total weight of the given familiar
 */
export declare function totalFamiliarWeight(familiar?: Familiar, considerAdjustment?: boolean): number;
export declare const regularFamiliarTags: readonly ["animal", "insect", "haseyes", "haswings", "fast", "bite", "flies", "hashands", "wearsclothes", "organic", "vegetable", "hovers", "edible", "food", "sentient", "cute", "mineral", "polygonal", "object", "undead", "cantalk", "evil", "orb", "spooky", "sleaze", "aquatic", "swims", "isclothes", "phallic", "stench", "hot", "hasbeak", "haslegs", "robot", "technological", "hard", "cold", "hasbones", "hasclaws", "reallyevil", "good", "person", "humanoid", "animatedart", "software", "hasshell", "hasstinger"];
export declare const pokefamUltTags: readonly ["ult_bearhug", "ult_sticktreats", "ult_owlstare", "ult_bloodbath", "ult_pepperscorn", "ult_rainbowstorm"];
export type PokefamUltTag = (typeof pokefamUltTags)[number];
export type RegularFamiliarTag = (typeof regularFamiliarTags)[number];
export type FamiliarTag = RegularFamiliarTag | PokefamUltTag;
/**
 * Type guard function to determine if a tag is a regular familiar tag or a pokefam ult
 * @param tag The familiar tag to check
 * @returns Asserts that `tag` is a `RegularFamiliarTag`
 */
export declare function isRegularFamiliarTag(tag: string): tag is RegularFamiliarTag;
/**
 * Find the tags (used in mumming trunk, stillsuit, etc) for a given familiar, EXCLUDING special tags used for pokefam ults
 * @param familiar The familiar in question
 * @returns An array of the familiar's tags
 */
export declare function getRegularFamiliarTags(familiar: Familiar): RegularFamiliarTag[];
/**
 * Find the tags (used in mumming trunk, stillsuit, etc) for a given familiar, INCLUDING special tags used for pokefam ults
 * @param familiar The familiar in question
 * @returns An array of the familiar's tags
 */
export declare function getAllFamiliarTags(familiar: Familiar): FamiliarTag[];
/**
 * Determines the cost of acquiring an item taking into account your valueOfInventory preference
 *
 * @param item The item to check the price of
 * @param quantity the number of items to acquire
 * @returns The total value of the items
 */
export declare function getAcquirePrice(item: Item, quantity?: number): number;
export {};
