import { Effect, Item } from "kolmafia";
type RawDietEntry<T> = [MenuItem<T>[], number];
type RawDiet<T> = RawDietEntry<T>[];
type MenuItemOptions<T> = Partial<{
    organ: Organ;
    size: number;
    maximum: number | "auto";
    additionalValue: number;
    effect: Effect;
    priceOverride: number;
    mayo: Item;
    data: T;
    useRetrievePrice: boolean;
}>;
export declare class MenuItem<T> {
    item: Item;
    organ?: Organ;
    size: number;
    maximum?: number;
    additionalValue?: number;
    effect?: Effect;
    priceOverride?: number;
    mayo?: Item;
    data?: T;
    private priceCached?;
    private itemTypeCached?;
    static defaultPriceFunction: (item: Item) => number;
    static defaultOptions<T>(): Map<Item, MenuItemOptions<T>>;
    /**
     * Construct a new menu item, possibly with extra properties. Items in MenuItem.defaultOptions have intelligent defaults.
     *
     * @param item Item to add to menu.
     * @param options Options for this menu item
     * @param options.organ Designate item as belonging to a specific organ.
     * @param options.size Override item organ size. Necessary for any non-food/booze/spleen item.
     * @param options.maximum Maximum uses remaining today, or "auto" to check dailyusesleft Mafia property.
     * @param options.additionalValue Additional value (positive) or cost (negative) to consider with item, e.g. from buffs.
     * @param options.effect Effect associated with this menu item (pocket wish effect, sweet synthesis effect, pill keeper potion extension)
     * @param options.mayo Which mayo to use before item (ignored if mayo clinic is not installed or item is not a food)
     * @param options.note Any note to track information about item, to be used later
     */
    constructor(item: Item, options?: MenuItemOptions<T>);
    equals(other: MenuItem<T>): boolean;
    toString(): string;
    price(): number;
    itemType(): string;
}
declare const organs: readonly ["food", "booze", "spleen item"];
type Organ = (typeof organs)[number];
declare class DietEntry<T> {
    quantity: number;
    menuItems: readonly MenuItem<T>[];
    constructor(menuItems: MenuItem<T>[], quantity: number);
    target(): MenuItem<T>;
    helpers(): MenuItem<T>[];
    expectedAdventures(diet: Diet<T>): number;
    expectedValue(mpa: number, diet: Diet<T>, method?: "gross" | "net"): number;
    expectedPrice(): number;
}
interface OrganCapacity {
    food?: number | "auto";
    booze?: number | "auto";
    spleen?: number | "auto";
}
/**
 * A representation of a potential diet
 */
export declare class Diet<T> {
    entries: DietEntry<T>[];
    constructor(entries?: DietEntry<T>[]);
    get refinedPalate(): boolean;
    get garish(): boolean;
    get saucemaven(): boolean;
    get tuxedoShirt(): boolean;
    get pinkyRing(): boolean;
    expectedAdventures(): number;
    expectedValue(mpa: number, method?: "gross" | "net"): number;
    expectedPrice(): number;
    copy(): Diet<T>;
    static from<T>(rawDiet: RawDiet<T>): Diet<T>;
    static plan<T>(mpa: number, menu: MenuItem<T>[], organCapacities?: OrganCapacity): Diet<T>;
}
export {};
