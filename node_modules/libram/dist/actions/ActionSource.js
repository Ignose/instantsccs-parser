import { useFamiliar } from "kolmafia";
import { Macro } from "../combat.js";
import { Requirement } from "../maximize.js";
import { sum } from "../utils.js";
import { getAcquirePrice } from "../lib.js";
/**
 * Merge a set of constraints into one
 *
 * @param allConstraints Constraints to mege
 * @returns Merged constraints
 */
function mergeConstraints(...allConstraints) {
    const familiars = allConstraints
        .map((constraints) => constraints.familiar)
        .filter(Boolean);
    if (familiars.length > 1) {
        // Inconsistent requirements.
        return null;
    }
    const familiar = familiars.find((familiar) => familiar);
    return {
        equipmentRequirements: () => Requirement.merge([
            ...allConstraints.map((constraints) => constraints.equipmentRequirements?.() ?? new Requirement([], {})),
        ]),
        preparation: () => {
            let success = true;
            for (const constraints of allConstraints) {
                success =
                    success && (!constraints.preparation || constraints.preparation());
            }
            return success;
        },
        ...(familiar ? { familiar } : {}),
        cost: () => sum(allConstraints, (constraints) => constraints.cost?.() ?? 0),
    };
}
/**
 * A combat-based action resource in the game (e.g. a free run or free kill).
 */
export class ActionSource {
    static defaultPriceFunction = (item) => getAcquirePrice(item) > 0 ? getAcquirePrice(item) : Infinity;
    source;
    potential; // Infinity: unlimited
    macro;
    constraints;
    /**
     * @param source Source(s) of the action (e.g. item, skill, or familiar needed).
     * @param potential Function returning how many times this action can be used.
     * @param macro Macro to execute this action in combat.
     * @param constraints Constraints required for this action to be available.
     */
    constructor(source, potential, macro, constraints = {}) {
        this.source = source;
        this.potential = potential;
        this.macro = macro;
        this.constraints = constraints;
    }
    /**
     * @returns Name of the action source.
     */
    name() {
        return this.source.toString();
    }
    /**
     * @returns Whether the action is available.
     */
    available() {
        return this.potential() > 0;
    }
    /**
     * @returns Cost in meat per usage of the action.
     */
    cost() {
        return this.constraints.cost ? this.constraints.cost() : 0;
    }
    /**
     * @returns Whether the action costs 0 meat to use.
     */
    isFree() {
        return !this.cost || this.cost() === 0;
    }
    /**
     * @returns Whether unlimited uses of the action are available.
     */
    isUnlimited() {
        return this.potential() === Infinity;
    }
    /**
     * Create a compound action source with merged constraints.
     *
     * @param others Other actions to have available.
     * @returns Merged constraints, or null if they are inconsistent.
     */
    merge(...others) {
        const actions = [this, ...others];
        const constraints = mergeConstraints(...actions.map((action) => action.constraints));
        if (constraints === null) {
            // Inconsistent constraints - no path forward here.
            return null;
        }
        return new ActionSource(actions.flatMap((action) => action.source), () => sum(actions, (action) => action.potential()), Macro.step(...actions.map((action) => action.macro)), constraints);
    }
    /**
     * Perform all preparation necessary to make this action available.
     *
     * @param otherRequirements Any other equipment requirements.
     * @returns Whether preparation succeeded.
     */
    prepare(otherRequirements) {
        if (this.constraints.familiar?.()) {
            if (!useFamiliar(this.constraints.familiar()))
                return false;
        }
        if (this.constraints.equipmentRequirements) {
            const requirement = otherRequirements
                ? otherRequirements.merge(this.constraints.equipmentRequirements())
                : this.constraints.equipmentRequirements();
            if (!requirement.maximize())
                return false;
        }
        if (this.constraints.preparation)
            return this.constraints.preparation();
        return true;
    }
    /**
     * Perform all preparation necessary to make this action available.
     * Throws an error if preparation fails.
     *
     * @param otherRequirements Any other equipment requirements.
     */
    ensure(otherRequirements) {
        if (!this.prepare(otherRequirements)) {
            throw new Error(`Failed to prepare action ${this.name()}.`);
        }
    }
}
/**
 * See if a supplied action meets a set of constraints
 *
 * @param action Action to test
 * @param constraints Constraints to apply
 * @returns Whether action meets constraints
 */
function filterAction(action, constraints) {
    return (action.available() &&
        (constraints.allowedAction === undefined ||
            constraints.allowedAction(action)) &&
        !(constraints.requireFamiliar?.() && !action.constraints.familiar) &&
        !(constraints.requireUnlimited?.() && !action.isUnlimited()) &&
        !(constraints.noFamiliar?.() && action.constraints.familiar) &&
        !(constraints.noRequirements?.() && action.constraints.equipmentRequirements) &&
        !(constraints.noPreparation?.() && action.constraints.preparation) &&
        action.cost() <= (constraints.maximumCost?.() ?? 0));
}
/**
 * Find an available action source subject to constraints.
 *
 * @param actions Action source list.
 * @param constraints Preexisting constraints that restrict possible sources.
 * @returns Available action source satisfying constraints, or null.
 */
export function findActionSource(actions, constraints = {}) {
    const validActions = actions.filter((actions) => filterAction(actions, constraints));
    if (validActions.length < 1)
        return null;
    return validActions.reduce((a, b) => (a.cost() <= b.cost() ? a : b));
}
/**
 * Count available action sources subject to constraints. Note that, if
 * constraints.maximumCost is high enough, this will return Infinity.
 *
 * @param actions Action source list.
 * @param constraints Preexisting constraints that restrict possible sources.
 * @returns Count of available action sources.
 */
export function actionSourcesAvailable(actions, constraints = {}) {
    // TODO: This will overcount if any Actions share a counter
    return sum(actions.filter((action) => filterAction(action, constraints ?? {})), (action) => action.potential());
}
