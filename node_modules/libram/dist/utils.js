/**
 * Type guard against null value
 *
 * @param value Value that could be null
 * @returns Confirmation that the value is not null
 */
export function notNull(value) {
    return value !== null;
}
/**
 * Type guard against nullish value
 *
 * @param value Value that could be null or undefined
 * @returns Confirmation that the value is not null nor undefined
 */
export function notNullish(value) {
    return notNull(value) && value !== undefined;
}
/**
 * Parse string to number, stripping commas
 *
 * @param n Numberical string to parse
 * @returns Numerical value of string
 */
export function parseNumber(n) {
    return Number.parseInt(n.replace(/,/g, ""));
}
/**
 * Clamp a number between lower and upper bounds.
 *
 * @param n Number to clamp.
 * @param min Lower bound.
 * @param max Upper bound.
 * @returns Clamped value
 */
export function clamp(n, min, max) {
    return Math.max(min, Math.min(max, n));
}
/**
 * Split an {@param array} into {@param chunkSize} sized chunks
 *
 * @param array Array to split
 * @param chunkSize Size of chunk
 * @returns Split array
 */
export function chunk(array, chunkSize) {
    const result = [];
    for (let i = 0; i < array.length; i += chunkSize) {
        result.push(array.slice(i, i + chunkSize));
    }
    return result;
}
/**
 * Count distinct values in an array
 *
 * @param array Array of values
 * @returns Map of distinct values to count
 */
export function arrayToCountedMap(array) {
    if (!Array.isArray(array))
        return array;
    const map = new Map();
    array.forEach((item) => {
        map.set(item, (map.get(item) || 0) + 1);
    });
    return map;
}
/**
 * Turn map of distinct values to count into array of values
 *
 * @param map Map to turn into array
 * @returns Array of values
 */
export function countedMapToArray(map) {
    return [].concat(...[...map].map(([item, quantity]) => Array(quantity).fill(item)));
}
/**
 * Stringify a counted map
 *
 * @param map Map of counted values
 * @returns String representing map of counted values
 */
export function countedMapToString(map) {
    return [...map].map(([item, quantity]) => `${quantity} x ${item}`).join(", ");
}
/**
 * Sum an array of numbers.
 *
 * @param addends Addends to sum.
 * @param x Property or mapping function of addends to sum
 * @returns Sum of numbers
 */
export function sum(addends, x) {
    return addends.reduce((subtotal, element) => subtotal + (typeof x === "function" ? x(element) : element[x]), 0);
}
/**
 * Sum array of numbers
 *
 * @param addends Numbers to sum
 * @returns Sum of numbers
 */
export function sumNumbers(addends) {
    return sum(addends, (x) => x);
}
/**
 * Checks if a given item is in a readonly array, acting as a typeguard.
 *
 * @param item Needle
 * @param array Readonly array haystack
 * @returns Whether the item is in the array, and narrows the type of the item.
 */
export function arrayContains(item, array) {
    return array.includes(item);
}
/**
 * Checks if two arrays contain the same elements in the same quantity.
 *
 * @param a First array for comparison
 * @param b Second array for comparison
 * @returns Whether the two arrays are equal, irrespective of order.
 */
export function setEqual(a, b) {
    const sortedA = [...a].sort();
    const sortedB = [...b].sort();
    return (a.length === b.length &&
        sortedA.every((item, index) => item === sortedB[index]));
}
/**
 * Reverses keys and values for a given map
 *
 * @param map Map to invert
 * @returns Inverted map
 */
export function invertMap(map) {
    const returnValue = new Map();
    for (const [key, value] of map) {
        returnValue.set(value, key);
    }
    return returnValue;
}
/**
 * Splits a string by commas while also respecting escaping commas with a backslash
 *
 * @param str String to split
 * @returns List of tokens
 */
export function splitByCommasWithEscapes(str) {
    const returnValue = [];
    let ignoreNext = false;
    let currentString = "";
    for (const char of str.split("")) {
        if (char === "\\") {
            ignoreNext = true;
        }
        else {
            if (char == "," && !ignoreNext) {
                returnValue.push(currentString.trim());
                currentString = "";
            }
            else {
                currentString += char;
            }
            ignoreNext = false;
        }
    }
    returnValue.push(currentString.trim());
    return returnValue;
}
/**
 * Find the best element of an array, where "best" is defined by some given criteria.
 *
 * @param array The array to traverse and find the best element of.
 * @param optimizer Either a key on the objects we're looking at that corresponds to numerical values, or a function for mapping these objects to numbers. Essentially, some way of assigning value to the elements of the array.
 * @param reverse Make this true to find the worst element of the array, and false to find the best. Defaults to false.
 * @returns Best element by optimizer function
 */
export function maxBy(array, optimizer, reverse = false) {
    if (!array.length)
        throw new Error("Cannot call maxBy on an empty array!");
    if (typeof optimizer === "function") {
        return [...array].reduce(({ value, item }, other) => {
            const otherValue = optimizer(other);
            return value >= otherValue !== reverse
                ? { value, item }
                : { value: otherValue, item: other };
        }, { item: array[0], value: optimizer(array[0]) }).item;
    }
    else {
        return array.reduce((a, b) => a[optimizer] >= b[optimizer] !== reverse ? a : b);
    }
}
/**
 * Let Typescript see that you're working with tuples!
 *
 * @param args A spread array to interpret as a tuple
 * @returns The given arg, its type now interpreted as a tuple
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function tuple(...args) {
    return args;
}
/**
 * Compare arrays shallowly
 *
 * @param left One array to compare
 * @param right The other array to compare
 * @returns Whether the two arrays are shallowly equal
 */
export function arrayEquals(left, right) {
    if (left.length !== right.length)
        return false;
    return left.every((element, index) => element === right[index]);
}
/**
 * Used to collapse a Delayed<T, S> object into an entity of type "T" as represented by the object.
 *
 * @param delayedObject Object of type Delayed<T, S> that represents either a value of type T or a function returning a value of type T.
 * @param args The arguments to pass to the delay function
 * @returns The return value of the function, if delayedObject is a function. Otherwise, this returns the original element.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function undelay(delayedObject, ...args) {
    return typeof delayedObject === "function"
        ? delayedObject(...args)
        : delayedObject;
}
/**
 * Makes a byX function, like byStat or byClass
 *
 * @param source A method for finding your stat, or class, or whatever X is in this context
 * @returns A function akin to byStat or byClass; it accepts an object that either is "complete" in the sense that it has a key for every conceivable value, or contains a `default` parameter. If an inappropriate input is provided, returns undefined.
 */
export function makeByXFunction(source) {
    return function (options, alternateSource) {
        const val = undelay(alternateSource ?? source);
        if ("default" in options)
            return options[val] ?? options.default;
        return options[val];
    };
}
/**
 * Flattens an array. Basically replacing Array.prototype.flat for which Rhino doesn't yet have an implementation
 * @deprecated KoLMafia now supports the `flat` and `flatMap` methods
 *
 * @param arr Array to flatten
 * @param depth Number of layers to flatten by; Infinity for a fully flat array
 * @returns Flattened array
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function flat(arr, depth = Infinity) {
    let flatArray = [];
    for (const item of arr) {
        if (Array.isArray(item) && depth > 0) {
            const child = flat(item, depth - 1);
            flatArray = flatArray.concat(child);
        }
        else {
            flatArray.push(item);
        }
    }
    return flatArray;
}
/**
 * @param array Array to select from
 * @returns Random item from array
 */
export function random(array) {
    return array[Math.floor(Math.random() * array.length)];
}
/**
 * Title cases a single word
 *
 * @param word Word to transform
 * @returns Word in title case
 */
export const tc = (word) => word.charAt(0).toUpperCase() + word.slice(1);
