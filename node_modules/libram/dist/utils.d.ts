/**
 * Type guard against null value
 *
 * @param value Value that could be null
 * @returns Confirmation that the value is not null
 */
export declare function notNull<T>(value: T | null): value is T;
/**
 * Type guard against nullish value
 *
 * @param value Value that could be null or undefined
 * @returns Confirmation that the value is not null nor undefined
 */
export declare function notNullish<T>(value: T | null | undefined): value is T;
/**
 * Parse string to number, stripping commas
 *
 * @param n Numberical string to parse
 * @returns Numerical value of string
 */
export declare function parseNumber(n: string): number;
/**
 * Clamp a number between lower and upper bounds.
 *
 * @param n Number to clamp.
 * @param min Lower bound.
 * @param max Upper bound.
 * @returns Clamped value
 */
export declare function clamp(n: number, min: number, max: number): number;
/**
 * Split an {@param array} into {@param chunkSize} sized chunks
 *
 * @param array Array to split
 * @param chunkSize Size of chunk
 * @returns Split array
 */
export declare function chunk<T>(array: T[], chunkSize: number): T[][];
/**
 * Count distinct values in an array
 *
 * @param array Array of values
 * @returns Map of distinct values to count
 */
export declare function arrayToCountedMap<T>(array: T[] | Map<T, number>): Map<T, number>;
/**
 * Turn map of distinct values to count into array of values
 *
 * @param map Map to turn into array
 * @returns Array of values
 */
export declare function countedMapToArray<T>(map: Map<T, number>): T[];
/**
 * Stringify a counted map
 *
 * @param map Map of counted values
 * @returns String representing map of counted values
 */
export declare function countedMapToString<T>(map: Map<T, number>): string;
/**
 * Sum an array of numbers.
 *
 * @param addends Addends to sum.
 * @param property Property of the elements to be summing
 * @returns Sum of numbers
 */
export declare function sum<S extends string | number | symbol, T extends {
    [s in S]: number;
}>(addends: readonly T[], property: S): number;
/**
 * Sum an array of numbers.
 *
 * @param addends Addends to sum.
 * @param mappingFunction Mapping function to turn addends into actual numbers.
 * @returns Sum of numbers
 */
export declare function sum<T>(addends: readonly T[], mappingFunction: (element: T) => number): number;
/**
 * Sum array of numbers
 *
 * @param addends Numbers to sum
 * @returns Sum of numbers
 */
export declare function sumNumbers(addends: number[]): number;
/**
 * Checks if a given item is in a readonly array, acting as a typeguard.
 *
 * @param item Needle
 * @param array Readonly array haystack
 * @returns Whether the item is in the array, and narrows the type of the item.
 */
export declare function arrayContains<T, A extends T>(item: T, array: ReadonlyArray<A>): item is A;
/**
 * Checks if two arrays contain the same elements in the same quantity.
 *
 * @param a First array for comparison
 * @param b Second array for comparison
 * @returns Whether the two arrays are equal, irrespective of order.
 */
export declare function setEqual<T>(a: T[], b: T[]): boolean;
/**
 * Reverses keys and values for a given map
 *
 * @param map Map to invert
 * @returns Inverted map
 */
export declare function invertMap<T1, T2>(map: Map<T1, T2>): Map<T2, T1>;
/**
 * Splits a string by commas while also respecting escaping commas with a backslash
 *
 * @param str String to split
 * @returns List of tokens
 */
export declare function splitByCommasWithEscapes(str: string): string[];
export declare function maxBy<T>(array: T[] | readonly T[], optimizer: (element: T) => number, reverse?: boolean): T;
export declare function maxBy<S extends string | number | symbol, T extends {
    [x in S]: number;
}>(array: T[] | readonly T[], key: S, reverse?: boolean): T;
/**
 * Let Typescript see that you're working with tuples!
 *
 * @param args A spread array to interpret as a tuple
 * @returns The given arg, its type now interpreted as a tuple
 */
export declare function tuple<T extends any[]>(...args: T): T;
export type Tuple<T, N extends number> = N extends N ? number extends N ? T[] : _tupleOf<T, N, []> : never;
type _tupleOf<T, N extends number, R extends unknown[]> = R["length"] extends N ? R : _tupleOf<T, N, [T, ...R]>;
/**
 * Compare arrays shallowly
 *
 * @param left One array to compare
 * @param right The other array to compare
 * @returns Whether the two arrays are shallowly equal
 */
export declare function arrayEquals<T>(left: T[] | readonly T[], right: T[] | readonly T[]): boolean;
/**
 * Type that extends any non-function entity--like a string, number, or array--into a itself and a no-input function that returns it.
 * Used to interact with objects that could either be functions or static values.
 */
export type Delayed<T, S extends any[] = never[]> = [T] extends [
    (...args: any) => any
] ? never : T | ((...args: S) => T);
/**
 * Used to collapse a Delayed<T, S> object into an entity of type "T" as represented by the object.
 *
 * @param delayedObject Object of type Delayed<T, S> that represents either a value of type T or a function returning a value of type T.
 * @param args The arguments to pass to the delay function
 * @returns The return value of the function, if delayedObject is a function. Otherwise, this returns the original element.
 */
export declare function undelay<T, S extends any[] = never[]>(delayedObject: Delayed<T, S>, ...args: S): T;
/**
 * An object keyed by string type T, with values of S.
 *  or contains a 'default' parameter to use as a fallback.
 */
export type Switch<T extends string, S> = Record<T, S> | (Partial<{
    [x in T]: S;
}> & {
    default: S;
});
/**
 * Makes a byX function, like byStat or byClass
 *
 * @param source A method for finding your stat, or class, or whatever X is in this context
 * @returns A function akin to byStat or byClass; it accepts an object that either is "complete" in the sense that it has a key for every conceivable value, or contains a `default` parameter. If an inappropriate input is provided, returns undefined.
 */
export declare function makeByXFunction<T extends string>(source: Delayed<T>): <S>(options: Switch<T, S>, alternateSource?: Delayed<T>) => S;
/**
 * Flattens an array. Basically replacing Array.prototype.flat for which Rhino doesn't yet have an implementation
 * @deprecated KoLMafia now supports the `flat` and `flatMap` methods
 *
 * @param arr Array to flatten
 * @param depth Number of layers to flatten by; Infinity for a fully flat array
 * @returns Flattened array
 */
export declare function flat<A extends any[], D extends number = 1>(arr: A, depth?: number): FlatArray<A, D>[];
/**
 * @param array Array to select from
 * @returns Random item from array
 */
export declare function random<T>(array: T[]): T;
/**
 * Title cases a single word
 *
 * @param word Word to transform
 * @returns Word in title case
 */
export declare const tc: (word: string) => string;
type Enumerate<N extends number, A extends number[] = []> = A["length"] extends N ? A[number] : Enumerate<N, [...A, A["length"]]>;
/**
 * Integers on the interval [A, B).
 */
export type Range<A extends number, B extends number> = Exclude<Enumerate<B>, Enumerate<A>>;
export type ValueOf<T> = T[keyof T];
export {};
