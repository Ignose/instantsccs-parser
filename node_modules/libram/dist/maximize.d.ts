import { Item, Slot } from "kolmafia";
export type MaximizeOptions = {
    updateOnFamiliarChange: boolean;
    updateOnCanEquipChanged: boolean;
    updateOnLocationChange: boolean;
    useOutfitCaching: boolean;
    forceEquip: Item[];
    preventEquip: Item[];
    bonusEquip: Map<Item, number>;
    onlySlot: Slot[];
    preventSlot: Slot[];
    forceUpdate: boolean;
    modes: Modes;
};
/**
 * Merges a partial set of maximizer options onto a full set maximizer options. We merge via overriding for all boolean properties and for onlySlot, and concat all other array properties.
 *
 * @param defaultOptions MaximizeOptions to use as a "base."
 * @param addendums Options to attempt to merge onto defaultOptions.
 * @returns Merged maximizer options
 */
export declare function mergeMaximizeOptions(defaultOptions: MaximizeOptions, addendums: Partial<MaximizeOptions>): MaximizeOptions;
/**
 *
 * @param options Default options for each maximizer run.
 * @param options.updateOnFamiliarChange Re-run the maximizer if familiar has changed. Default true.
 * @param options.updateOnCanEquipChanged Re-run the maximizer if stats have changed what can be equipped. Default true.
 * @param options.forceEquip Equipment to force-equip ("equip X").
 * @param options.preventEquip Equipment to prevent equipping ("-equip X").
 * @param options.bonusEquip Equipment to apply a bonus to ("200 bonus X").
 */
export declare function setDefaultMaximizeOptions(options: Partial<MaximizeOptions>): void;
declare const modeableCommands: readonly ["backupcamera", "umbrella", "snowsuit", "edpiece", "retrocape", "parka", "jillcandle"];
export type Mode = (typeof modeableCommands)[number];
export type Modes = Partial<{
    [x in Mode]: string;
}>;
export declare const modeableItems: {
    readonly backupcamera: Item;
    readonly umbrella: Item;
    readonly snowsuit: Item;
    readonly edpiece: Item;
    readonly retrocape: Item;
    readonly parka: Item;
    readonly jillcandle: Item;
};
export declare const modeableState: {
    readonly backupcamera: () => string;
    readonly umbrella: () => string;
    readonly snowsuit: () => string;
    readonly edpiece: () => string;
    readonly retrocape: () => string;
    readonly parka: () => string;
    readonly jillcandle: () => string;
};
/**
 * Get set of current modes for modeables
 *
 * @returns Set of modes
 */
export declare function getCurrentModes(): Modes;
/**
 * Apply set of modes
 *
 * @param modes Modes to apply
 */
export declare function applyModes(modes: Modes): void;
/**
 * Run the maximizer, but only if the objective and certain pieces of game state haven't changed since it was last run.
 *
 * @param objectives Objectives to maximize for.
 * @param options Options for this run of the maximizer.
 * @param options.updateOnFamiliarChange Re-run the maximizer if familiar has changed. Default true.
 * @param options.updateOnCanEquipChanged Re-run the maximizer if stats have changed what can be equipped. Default true.
 * @param options.forceEquip Equipment to force-equip ("equip X").
 * @param options.preventEquip Equipment to prevent equipping ("-equip X").
 * @param options.bonusEquip Equipment to apply a bonus to ("200 bonus X").
 * @returns Whether the maximize call succeeded.
 */
export declare function maximizeCached(objectives: string[], options?: Partial<MaximizeOptions>): boolean;
export declare class Requirement {
    #private;
    /**
     * A convenient way of combining maximization parameters and options
     *
     * @param maximizeParameters Parameters you're attempting to maximize
     * @param maximizeOptions Object potentially containing forceEquips, bonusEquips, preventEquips, and preventSlots
     */
    constructor(maximizeParameters: string[], maximizeOptions: Partial<MaximizeOptions>);
    get maximizeParameters(): string[];
    get maximizeOptions(): Partial<MaximizeOptions>;
    /**
     * Merges two requirements, concanating relevant arrays. Typically used in static form.
     *
     * @param other Requirement to merge with.
     * @returns A new merged Requirement
     */
    merge(other: Requirement): Requirement;
    /**
     * Merges a set of requirements together, starting with an empty requirement.
     *
     * @param allRequirements Requirements to merge
     * @returns Merged requirements
     */
    static merge(allRequirements: Requirement[]): Requirement;
    /**
     * Runs maximizeCached, using the maximizeParameters and maximizeOptions contained by this requirement.
     *
     * @returns Whether the maximize call succeeded.
     */
    maximize(): boolean;
    /**
     * Merges requirements, and then runs maximizeCached on the combined requirement.
     *
     * @param requirements Requirements to maximize on
     */
    static maximize(...requirements: Requirement[]): void;
}
/**
 * Clear all outfits cached by the maximizer.
 */
export declare function clearMaximizerCache(): void;
export {};
