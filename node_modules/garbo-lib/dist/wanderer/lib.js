"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bofaValue = exports.wandererTurnsAvailableToday = exports.defaultFactory = exports.WandererTarget = exports.canWander = exports.unlock = exports.canAdventureOrUnlock = exports.underwater = exports.UnlockableZones = exports.isDraggableFight = exports.draggableFights = void 0;
const kolmafia_1 = require("kolmafia");
const libram_1 = require("libram");
exports.draggableFights = [
    "backup",
    "wanderer",
    "yellow ray",
    "freefight",
];
function isDraggableFight(fight) {
    return exports.draggableFights.includes(fight);
}
exports.isDraggableFight = isDraggableFight;
exports.UnlockableZones = [
    {
        zone: "Spaaace",
        available: () => (0, libram_1.have)((0, libram_1.$effect) `Transpondent`),
        unlocker: (0, libram_1.$item) `transporter transponder`,
        noInv: false,
    },
    {
        zone: "Wormwood",
        available: () => (0, libram_1.have)((0, libram_1.$effect) `Absinthe-Minded`),
        unlocker: (0, libram_1.$item) `tiny bottle of absinthe`,
        noInv: false,
    },
    {
        zone: "Rabbit Hole",
        available: () => (0, libram_1.have)((0, libram_1.$effect) `Down the Rabbit Hole`),
        unlocker: (0, libram_1.$item) `"DRINK ME" potion`,
        noInv: false,
    },
    {
        zone: "Conspiracy Island",
        available: () => (0, libram_1.realmAvailable)("spooky"),
        unlocker: (0, libram_1.$item) `one-day ticket to Conspiracy Island`,
        noInv: true,
    },
    {
        zone: "Dinseylandfill",
        available: () => (0, libram_1.realmAvailable)("stench"),
        unlocker: (0, libram_1.$item) `one-day ticket to Dinseylandfill`,
        noInv: true,
    },
    {
        zone: "The Glaciest",
        available: () => (0, libram_1.realmAvailable)("cold"),
        unlocker: (0, libram_1.$item) `one-day ticket to The Glaciest`,
        noInv: true,
    },
    {
        zone: "Spring Break Beach",
        available: () => (0, libram_1.realmAvailable)("sleaze"),
        unlocker: (0, libram_1.$item) `one-day ticket to Spring Break Beach`,
        noInv: true,
    },
];
function underwater(location) {
    return location.environment === "underwater";
}
exports.underwater = underwater;
const ILLEGAL_PARENTS = ["Clan Basement", "Psychoses", "PirateRealm"];
const ILLEGAL_ZONES = ["The Drip"];
const canAdventureOrUnlockSkipList = [
    ...(0, libram_1.$locations) `The Oasis, The Bubblin' Caldera, Barrrney's Barrr, The F'c'le, The Poop Deck, Belowdecks, Madness Bakery, The Secret Government Laboratory, The Dire Warren, Inside the Palindome, The Haiku Dungeon, An Incredibly Strange Place (Bad Trip), An Incredibly Strange Place (Mediocre Trip), An Incredibly Strange Place (Great Trip), El Vibrato Island, The Daily Dungeon, Trick-or-Treating, Seaside Megalopolis`,
    ...kolmafia_1.Location.all().filter(({ parent, zone }) => ILLEGAL_PARENTS.includes(parent) || ILLEGAL_ZONES.includes(zone)),
];
function canAdventureOrUnlock(loc) {
    const skiplist = [...canAdventureOrUnlockSkipList];
    if (!(0, libram_1.have)((0, libram_1.$item) `repaid diaper`) &&
        (0, libram_1.have)((0, libram_1.$item) `Great Wolf's beastly trousers`)) {
        skiplist.push((0, libram_1.$location) `The Icy Peak`);
    }
    const canUnlock = exports.UnlockableZones.some((z) => loc.zone === z.zone && (z.available() || !z.noInv));
    return (!underwater(loc) &&
        !skiplist.includes(loc) &&
        ((0, kolmafia_1.canAdventure)(loc) || canUnlock));
}
exports.canAdventureOrUnlock = canAdventureOrUnlock;
function unlock(loc, value) {
    const unlockableZone = exports.UnlockableZones.find((z) => z.zone === loc.zone);
    if (!unlockableZone)
        return (0, kolmafia_1.canAdventure)(loc);
    if (unlockableZone.available())
        return true;
    if ((0, kolmafia_1.buy)(1, unlockableZone.unlocker, value) === 0)
        return false;
    return (0, kolmafia_1.use)(unlockableZone.unlocker);
}
exports.unlock = unlock;
const backupSkiplist = (0, libram_1.$locations) `The Overgrown Lot, The Skeleton Store, The Mansion of Dr. Weirdeaux, Professor Jacking's Huge-A-Ma-tron`;
// These are locations where all non-combats have skips or lead to a combat.
const backupSafelist = (0, libram_1.$locations) `The Haunted Gallery, The Haunted Ballroom, The Haunted Library, The Penultimate Fantasy Airship, Cobb's Knob Barracks, The Castle in the Clouds in the Sky (Basement), The Castle in the Clouds in the Sky (Ground Floor), The Castle in the Clouds in the Sky (Top Floor), The Haiku Dungeon, Twin Peak, A Mob of Zeppelin Protesters, The Upper Chamber`;
// These are locations where all non-combats are skippable
const yellowRaySafelist = (0, libram_1.$locations) `The Haunted Gallery, The Haunted Ballroom, The Haunted Library, Cobb's Knob Barracks, The Castle in the Clouds in the Sky (Basement), The Castle in the Clouds in the Sky (Ground Floor), The Haiku Dungeon, Twin Peak, A Mob of Zeppelin Protesters, The Upper Chamber`;
function canWanderTypeBackup(location) {
    return (!backupSkiplist.includes(location) &&
        (location.combatPercent >= 100 || backupSafelist.includes(location)));
}
function canWanderTypeFreeFight(location) {
    if (location === (0, libram_1.$location) `The Fun-Guy Mansion` &&
        (0, libram_1.get)("funGuyMansionKills", 0) >= 100) {
        return false;
    }
    return (!backupSkiplist.includes(location) &&
        (location.combatPercent >= 100 || yellowRaySafelist.includes(location)));
}
const wandererSkiplist = (0, libram_1.$locations) `The Batrat and Ratbat Burrow, Guano Junction, The Beanbat Chamber, A-Boo Peak, The Mouldering Mansion, The Rogue Windmill, The Stately Pleasure Dome`;
function canWanderTypeWander(location) {
    return !wandererSkiplist.includes(location) && location.wanderers;
}
function canWander(location, type) {
    if (underwater(location))
        return false;
    switch (type) {
        case "backup":
            return canWanderTypeBackup(location);
        case "freefight":
        case "yellow ray":
            return canWanderTypeFreeFight(location);
        case "wanderer":
            return canWanderTypeWander(location);
    }
}
exports.canWander = canWander;
class WandererTarget {
    name;
    value;
    location;
    prepareTurn;
    /**
     * Process for determining where to put a wanderer to extract additional value from it
     * @param name name of this wanderer - for documentation/logging purposes
     * @param location returns the location to adventure to target this; null only if something goes wrong
     * @param value the expected additional value of putting a single wanderer-fight into the zone for this
     * @param prepareTurn attempt to set up, spending meat and or items as necessary
     */
    constructor(name, location, value, prepareTurn = () => true) {
        this.name = name;
        this.value = value;
        this.location = location;
        this.prepareTurn = prepareTurn;
    }
}
exports.WandererTarget = WandererTarget;
function defaultFactory() {
    return [new WandererTarget("Default", (0, libram_1.$location) `The Haunted Kitchen`, 0)];
}
exports.defaultFactory = defaultFactory;
const WanderingSources = [
    {
        name: "CMG",
        item: (0, libram_1.$item) `cursed magnifying glass`,
        max: 3,
        property: "_voidFreeFights",
        type: "wanderer",
    },
    {
        name: "Voter",
        item: (0, libram_1.$item) `"I Voted!" sticker`,
        max: 3,
        property: "_voteFreeFights",
        type: "wanderer",
    },
    {
        name: "Voter",
        item: (0, libram_1.$item) `"I Voted!" sticker`,
        max: 3,
        property: "_voteFreeFights",
        type: "wanderer",
    },
    {
        name: "Backup",
        item: (0, libram_1.$item) `backup camera`,
        max: 11,
        property: "_backUpUses",
        type: "backup",
    },
];
function wandererTurnsAvailableToday(options, location) {
    const canWanderCache = {
        backup: canWander(location, "backup"),
        wanderer: canWander(location, "wanderer"),
        "yellow ray": canWander(location, "yellow ray"),
        freefight: canWander(location, "freefight"),
    };
    const digitize = canWanderCache["backup"] && options.digitzesRemaining
        ? options.digitzesRemaining(options.estimatedTurns())
        : 0;
    const pigSkinnerRay = canWanderCache["backup"] && (0, libram_1.have)((0, libram_1.$skill) `Free-For-All`)
        ? Math.floor(options.estimatedTurns() / 25)
        : 0;
    const yellowRayCooldown = (0, libram_1.have)((0, libram_1.$skill) `Fondeluge`) ? 50 : 100;
    const yellowRay = canWanderCache["yellow ray"]
        ? Math.floor(options.estimatedTurns() / yellowRayCooldown)
        : 0;
    const wanderers = (0, libram_1.sum)(WanderingSources, (source) => canWanderCache[source.type] && (0, libram_1.have)(source.item)
        ? (0, libram_1.clamp)((0, libram_1.get)(source.property), 0, source.max)
        : 0);
    return digitize + pigSkinnerRay + yellowRay + wanderers;
}
exports.wandererTurnsAvailableToday = wandererTurnsAvailableToday;
const LIMITED_BOFA_DROPS = (0, libram_1.$items) `pocket wish, tattered scrap of paper`;
function bofaValue({ plentifulMonsters, itemValue, effectValue }, monster) {
    switch (monster.factType) {
        case "item": {
            const item = (0, kolmafia_1.itemFact)(monster);
            const quantity = (0, kolmafia_1.numericFact)(monster);
            if (LIMITED_BOFA_DROPS.includes(item) &&
                plentifulMonsters.some((monster) => (0, kolmafia_1.toItem)(monster.fact) === item)) {
                return 0;
            }
            return quantity * itemValue(item);
        }
        case "effect": {
            const effect = (0, kolmafia_1.effectFact)(monster);
            const duration = (0, kolmafia_1.numericFact)(monster);
            return effectValue(effect, duration);
        }
        case "meat": {
            return (0, kolmafia_1.numericFact)(monster);
        }
        default:
            return 0;
    }
}
exports.bofaValue = bofaValue;
