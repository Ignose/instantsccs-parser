/* eslint-disable @typescript-eslint/no-explicit-any */
import { Class, Effect, Familiar, getProperty, isDarkMode, Item, Location, Monster, Path, printHtml, Skill, } from "kolmafia";
export class Args {
    static custom(spec, parser, valueHelpName) {
        var _a, _b;
        const raw_options = (_a = spec.options) === null || _a === void 0 ? void 0 : _a.map((option) => option[0]);
        // Check that the default value actually appears in the options.
        if ("default" in spec && raw_options) {
            if (!raw_options.includes(spec.default)) {
                throw `Invalid default value ${spec.default}`;
            }
        }
        return {
            ...spec,
            valueHelpName: valueHelpName,
            parser: (value) => {
                const parsed_value = parser(value);
                if (parsed_value === undefined || parsed_value instanceof ParseError)
                    return parsed_value;
                if (raw_options) {
                    if (!raw_options.includes(parsed_value)) {
                        return new ParseError(`received ${value} which was not in the allowed options`);
                    }
                }
                return parsed_value;
            },
            options: (_b = spec.options) === null || _b === void 0 ? void 0 : _b.map((a) => [`${a[0]}`, a[1]]),
        };
    }
    static arrayFromArg(spec, argFromSpec) {
        var _a, _b, _c;
        // First, construct a non-array version of this argument.
        // We do this by calling argFromSpec in order to extract the parser and
        // valueHelpName (to make it easier to define the functions below).
        //
        // The default argument of an ArraySpec is of type T[], which causes
        // problems, so we must remove it.
        const spec_without_default = { ...spec }; // Avoid "the operand of a 'delete' operator must be optional"
        if ("default" in spec_without_default)
            delete spec_without_default["default"];
        const arg = argFromSpec.call(this, spec_without_default);
        // Next, check that all default values actually appear in the options.
        const raw_options = (_a = spec.options) === null || _a === void 0 ? void 0 : _a.map((option) => option[0]);
        if ("default" in spec && raw_options) {
            for (const default_entry of spec.default) {
                if (!raw_options.includes(default_entry))
                    throw `Invalid default value ${spec.default}`;
            }
        }
        const separator = (_b = spec.separator) !== null && _b !== void 0 ? _b : ",";
        const arrayParser = (value) => {
            // Split the array
            let values = value.split(separator);
            if (!spec.noTrim)
                values = values.map((v) => v.trim());
            // Parse all values, return the first error found if any
            const result = values.map((v) => arg.parser(v));
            const error = result.find((v) => v instanceof ParseError);
            if (error)
                return error;
            const failure_index = result.indexOf(undefined);
            if (failure_index !== -1)
                return new ParseError(`components expected ${arg.valueHelpName} but could not parse ${values[failure_index]}`);
            // Otherwise, all values are good
            return result;
        };
        return {
            ...spec,
            valueHelpName: `${arg.valueHelpName}${separator} ${arg.valueHelpName}${separator} ...`,
            parser: arrayParser,
            options: (_c = spec.options) === null || _c === void 0 ? void 0 : _c.map((a) => [`${a[0]}`, a[1]]),
        };
    }
    static string(spec) {
        return this.custom(spec, (value) => value, "TEXT");
    }
    static strings(spec) {
        return this.arrayFromArg(spec, this.string);
    }
    static number(spec) {
        return this.custom(spec, (value) => (isNaN(Number(value)) ? undefined : Number(value)), "NUMBER");
    }
    static numbers(spec) {
        return this.arrayFromArg(spec, this.number);
    }
    static boolean(spec) {
        return this.custom(spec, (value) => {
            if (value.toLowerCase() === "true")
                return true;
            if (value.toLowerCase() === "false")
                return false;
            return undefined;
        }, "BOOLEAN");
    }
    static booleans(spec) {
        return this.arrayFromArg(spec, this.boolean);
    }
    static flag(spec) {
        return this.custom(spec, (value) => {
            if (value.toLowerCase() === "true")
                return true;
            if (value.toLowerCase() === "false")
                return false;
            return undefined;
        }, "FLAG");
    }
    static class(spec) {
        return this.custom(spec, (value) => {
            const match = Class.get(value);
            // Class.get does fuzzy matching:
            //  e.g. Class.get("sc") returns disco bandit.
            // To avoid this foot-gun, only return exact matches or id lookups.
            if (match.toString().toUpperCase() === value.toString().toUpperCase())
                return match;
            if (!isNaN(Number(value)))
                return match;
            return undefined;
        }, "CLASS");
    }
    static classes(spec) {
        return this.arrayFromArg(spec, this.class);
    }
    static effect(spec) {
        return this.custom(spec, Effect.get, "EFFECT");
    }
    static effects(spec) {
        return this.arrayFromArg(spec, this.effect);
    }
    static familiar(spec) {
        return this.custom(spec, Familiar.get, "FAMILIAR");
    }
    static familiars(spec) {
        return this.arrayFromArg(spec, this.familiar);
    }
    static item(spec) {
        return this.custom(spec, Item.get, "ITEM");
    }
    static items(spec) {
        return this.arrayFromArg(spec, this.item);
    }
    static location(spec) {
        return this.custom(spec, Location.get, "LOCATION");
    }
    static locations(spec) {
        return this.arrayFromArg(spec, this.location);
    }
    static monster(spec) {
        return this.custom(spec, Monster.get, "MONSTER");
    }
    static monsters(spec) {
        return this.arrayFromArg(spec, this.monster);
    }
    static path(spec) {
        return this.custom(spec, Path.get, "PATH");
    }
    static paths(spec) {
        return this.arrayFromArg(spec, this.path);
    }
    static skill(spec) {
        return this.custom(spec, Skill.get, "SKILL");
    }
    static skills(spec) {
        return this.arrayFromArg(spec, this.skill);
    }
    /**
     * Create a group of arguments that will be printed separately in the help.
     *
     * Note that keys in the group must still be globally distinct.
     *
     * @param groupName The display name for the group in help.
     * @param args A JS object specifying the script arguments. Its values should
     *    be {@link Arg} objects (created by Args.string, Args.number, or others)
     *    or groups of arguments (created by Args.group).
     */
    static group(groupName, args) {
        return {
            name: groupName,
            args: args,
        };
    }
    /**
     * Create a set of input arguments for a script.
     * @param scriptName Prefix for property names; often the name of the script.
     * @param scriptHelp Brief description of this script, for the help message.
     * @param args A JS object specifying the script arguments. Its values should
     *    be {@link Arg} objects (created by Args.string, Args.number, or others)
     *    or groups of arguments (created by Args.group).
     * @param options Config options for the args and arg parser.
     * @returns An object which can hold parsed argument values. The keys of this
     *    object are identical to the keys in 'args'.
     */
    static create(scriptName, scriptHelp, args, options) {
        traverse(args, (keySpec, key) => {
            if (key === "help" || keySpec.key === "help")
                throw `help is a reserved argument name`;
        });
        const argsWithHelp = {
            ...args,
            help: this.flag({ help: "Show this message and exit.", setting: "" }),
        };
        // Create an object to hold argument results, with a default value for
        // each argument.
        const res = {
            ...loadDefaultValues(argsWithHelp),
            [specSymbol]: argsWithHelp,
            [scriptSymbol]: scriptName,
            [scriptHelpSymbol]: scriptHelp,
            [optionsSymbol]: options !== null && options !== void 0 ? options : {},
        };
        if (options === null || options === void 0 ? void 0 : options.positionalArgs) {
            const keys = [];
            const metadata = Args.getMetadata(res);
            metadata.traverse((keySpec, key) => {
                var _a;
                keys.push((_a = keySpec.key) !== null && _a !== void 0 ? _a : key);
            });
            for (const arg of options.positionalArgs) {
                if (!keys.includes(arg))
                    throw `Unknown key for positional arg: ${arg}`;
            }
        }
        return res;
    }
    /**
     * Parse the command line input into the provided script arguments.
     * @param args An object to hold the parsed argument values, from Args.create(*).
     * @param command The command line input.
     * @param includeSettings If true, parse values from settings as well.
     */
    static fill(args, command, includeSettings = true) {
        var _a;
        const metadata = Args.getMetadata(args);
        // Load the list of keys and flags from the arg spec
        const keys = new Set();
        const flags = new Set();
        metadata.traverse((keySpec, key) => {
            var _a;
            const name = (_a = keySpec.key) !== null && _a !== void 0 ? _a : key;
            if (flags.has(name) || keys.has(name))
                throw `Duplicate arg key ${name} is not allowed`;
            if (keySpec.valueHelpName === "FLAG")
                flags.add(name);
            else
                keys.add(name);
        });
        // Parse values from settings.
        if (includeSettings) {
            metadata.traverseAndMaybeSet(args, (keySpec, key) => {
                var _a, _b;
                const setting = (_a = keySpec.setting) !== null && _a !== void 0 ? _a : `${metadata.scriptName}_${(_b = keySpec.key) !== null && _b !== void 0 ? _b : key}`;
                if (setting === "")
                    return undefined; // no setting
                const value_str = getProperty(setting);
                if (value_str === "")
                    return undefined; // no setting
                return parseAndValidate(keySpec, `Setting ${setting}`, value_str);
            });
        }
        // Parse new argments from the command line
        if (command === undefined || command === "")
            return;
        const parsed = new CommandParser(command, keys, flags, (_a = metadata.options.positionalArgs) !== null && _a !== void 0 ? _a : []).parse();
        metadata.traverseAndMaybeSet(args, (keySpec, key) => {
            var _a;
            const argKey = (_a = keySpec.key) !== null && _a !== void 0 ? _a : key;
            const value_str = parsed.get(argKey);
            if (value_str === undefined)
                return undefined; // no setting
            return parseAndValidate(keySpec, `Argument ${argKey}`, value_str);
        });
    }
    /**
     * Parse command line input into a new set of script arguments.
     * @param scriptName Prefix to use in property names; typically the name of the script.
     * @param scriptHelp Brief description of this script, for the help message.
     * @param spec An object specifying the script arguments.
     * @param command The command line input.
     * @param options Config options for the args and arg parser.
     */
    static parse(scriptName, scriptHelp, spec, command, options) {
        const args = this.create(scriptName, scriptHelp, spec, options);
        this.fill(args, command);
        return args;
    }
    /**
     * Print a description of the script arguments to the CLI.
     *
     * First, all top-level argument descriptions are printed in the order they
     * were defined. Afterwards, descriptions for groups of arguments are printed
     * in the order they were defined.
     *
     * @param args An object of parsed arguments, from Args.create(*).
     * @param maxOptionsToDisplay If given, do not list more than this many options for each arg.
     */
    static showHelp(args, maxOptionsToDisplay) {
        var _a;
        const metadata = Args.getMetadata(args);
        printHtml(`${metadata.scriptHelp}`);
        printHtml("");
        printHtml(`<b>${(_a = metadata.options.defaultGroupName) !== null && _a !== void 0 ? _a : "Options"}:</b>`);
        metadata.traverse((arg, key) => {
            var _a, _b, _c, _d, _e;
            if (arg.hidden)
                return;
            const nameText = `<font color='${isDarkMode() ? "yellow" : "blue"}'>${(_a = arg.key) !== null && _a !== void 0 ? _a : key}</font>`;
            const valueText = arg.valueHelpName === "FLAG" ? "" : `<font color='purple'>${arg.valueHelpName}</font>`;
            const helpText = (_b = arg.help) !== null && _b !== void 0 ? _b : "";
            const defaultText = "default" in arg ? `<font color='#888888'>[default: ${arg.default}]</font>` : "";
            const settingText = arg.setting === ""
                ? ""
                : `<font color='#888888'>[setting: ${(_c = arg.setting) !== null && _c !== void 0 ? _c : `${metadata.scriptName}_${(_d = arg.key) !== null && _d !== void 0 ? _d : key}`}]</font>`;
            printHtml(`&nbsp;&nbsp;${[nameText, valueText, "-", helpText, defaultText, settingText].join(" ")}`);
            const valueOptions = (_e = arg.options) !== null && _e !== void 0 ? _e : [];
            if (valueOptions.length < (maxOptionsToDisplay !== null && maxOptionsToDisplay !== void 0 ? maxOptionsToDisplay : Number.MAX_VALUE)) {
                for (const option of valueOptions) {
                    if (option.length === 1 || option[1] === undefined) {
                        printHtml(`&nbsp;&nbsp;&nbsp;&nbsp;<font color='blue'>${nameText}</font> ${option[0]}`);
                    }
                    else {
                        printHtml(`&nbsp;&nbsp;&nbsp;&nbsp;<font color='blue'>${nameText}</font> ${option[0]} - ${option[1]}`);
                    }
                }
            }
        }, (group) => {
            printHtml("");
            printHtml(`<b>${group.name}:</b>`);
        });
    }
    /**
     * Load the metadata information for a set of arguments. Only for advanced usage.
     *
     * @param args A JS object specifying the script arguments. Its values should
     *    be {@link Arg} objects (created by Args.string, Args.number, or others)
     *    or groups of arguments (created by Args.group).
     * @returns A class containing metadata information.
     */
    static getMetadata(args) {
        return new WrappedArgMetadata(args);
    }
}
export class ParseError {
    constructor(message) {
        this.message = message;
    }
}
/**
 * Metadata for the parsed arguments.
 *
 * This information is hidden within the parsed argument object so that it
 * is invisible to the user but available to fill(*) and showHelp(*).
 */
const specSymbol = Symbol("spec");
const scriptSymbol = Symbol("script");
const scriptHelpSymbol = Symbol("scriptHelp");
const optionsSymbol = Symbol("options");
/**
 * Parse a string into a value for a given argument, throwing if the parsing fails.
 * @param arg An argument that takes values in T.
 * @param source A description of where this value came from, for the error message.
 * @param value The value to parse.
 * @returns the parsed value.
 */
function parseAndValidate(arg, source, value) {
    let parsed_value;
    try {
        parsed_value = arg.parser(value);
    }
    catch (_a) {
        parsed_value = undefined;
    }
    if (parsed_value === undefined)
        throw `${source} expected ${arg.valueHelpName} but could not parse ${value}`;
    if (parsed_value instanceof ParseError)
        throw `${source} ${parsed_value.message}`;
    return parsed_value;
}
/**
 * A class that reveals the hidden metadata and specs for arguments.
 *
 * Only for advanced usage.
 */
class WrappedArgMetadata {
    constructor(args) {
        this.spec = args[specSymbol];
        this.scriptName = args[scriptSymbol];
        this.scriptHelp = args[scriptHelpSymbol];
        this.options = args[optionsSymbol];
    }
    /**
     * Create a parsed args object from this spec using all default values.
     */
    loadDefaultValues() {
        return loadDefaultValues(this.spec);
    }
    /**
     * Traverse the spec and possibly generate a value for each argument.
     *
     * @param result The object to hold the resulting argument values, typically
     *    the result of loadDefaultValues().
     * @param setTo A function to generate an argument value from each arg spec.
     *    If this function returns undefined, then the argument value is unchanged.
     */
    traverseAndMaybeSet(result, setTo) {
        return traverseAndMaybeSet(this.spec, result, setTo);
    }
    /**
     * Traverse the spec and call a method for each argument.
     *
     * @param process A function to call at each arg spec.
     */
    traverse(process, onGroup) {
        return traverse(this.spec, process, onGroup);
    }
}
/**
 * Create a parsed args object from a spec using all default values.
 *
 * @param spec The spec for all arguments.
 */
function loadDefaultValues(spec) {
    const result = {};
    for (const k in spec) {
        const argSpec = spec[k];
        if ("args" in argSpec) {
            result[k] = loadDefaultValues(argSpec.args);
        }
        else {
            if ("default" in argSpec)
                result[k] = argSpec.default;
            else
                result[k] = undefined;
        }
    }
    return result;
}
/**
 * Traverse the spec and possibly generate a value for each argument.
 *
 * @param spec The spec for all arguments.
 * @param result The object to hold the resulting argument values.
 * @param setTo A function to generate an argument value from each arg spec.
 *    If this function returns undefined, then the argument value is unchanged.
 */
function traverseAndMaybeSet(spec, result, setTo) {
    const groups = [];
    for (const k in spec) {
        const argSpec = spec[k];
        if ("args" in argSpec) {
            groups.push([argSpec, k]);
        }
        else {
            const value = setTo(argSpec, k);
            if (value === undefined)
                continue;
            result[k] = value;
        }
    }
    for (const group_and_key of groups) {
        traverseAndMaybeSet(group_and_key[0].args, result[group_and_key[1]], setTo);
    }
}
/**
 * Traverse the spec and possibly generate a value for each argument.
 *
 * @param spec The spec for all arguments.
 * @param process A function to call at each arg spec.
 */
function traverse(spec, process, onGroup) {
    const groups = [];
    for (const k in spec) {
        const argSpec = spec[k];
        if ("args" in argSpec) {
            groups.push([argSpec, k]);
        }
        else {
            process(argSpec, k);
        }
    }
    for (const group_and_key of groups) {
        onGroup === null || onGroup === void 0 ? void 0 : onGroup(group_and_key[0], group_and_key[1]);
        traverse(group_and_key[0].args, process, onGroup);
    }
}
/**
 * A parser to extract key/value pairs from a command line input.
 * @member command The command line input.
 * @member keys The set of valid keys that can appear.
 * @member flags The set of valid flags that can appear.
 * @member index An internal marker for the progress of the parser over the input.
 */
class CommandParser {
    constructor(command, keys, flags, positionalArgs) {
        this.command = command;
        this.index = 0;
        this.keys = keys;
        this.flags = flags;
        this.positionalArgs = positionalArgs;
        this.positionalArgsParsed = 0;
    }
    /**
     * Perform the parsing of (key, value) pairs.
     * @returns The set of extracted (key, value) pairs.
     */
    parse() {
        var _a, _b, _c, _d;
        this.index = 0; // reset the parser
        const result = new Map();
        while (!this.finished()) {
            // A flag F may appear as !F to be parsed as false.
            let parsing_negative_flag = false;
            if (this.peek() === "!") {
                parsing_negative_flag = true;
                this.consume(["!"]);
            }
            const startIndex = this.index;
            const key = this.parseKey();
            if (result.has(key)) {
                throw `Duplicate key ${key} (first set to ${(_a = result.get(key)) !== null && _a !== void 0 ? _a : ""})`;
            }
            if (this.flags.has(key)) {
                // The key corresponds to a flag.
                // Parse [key] as true and ![key] as false.
                result.set(key, parsing_negative_flag ? "false" : "true");
                if (this.peek() === "=")
                    throw `Flag ${key} cannot be assigned a value`;
                if (!this.finished())
                    this.consume([" "]);
                this.prevUnquotedKey = undefined;
            }
            else if (this.keys.has(key)) {
                // Parse [key]=[value] or [key] [value]
                this.consume(["=", " "]);
                const value = this.parseValue();
                if (["'", '"'].includes((_b = this.prev()) !== null && _b !== void 0 ? _b : ""))
                    this.prevUnquotedKey = undefined;
                else
                    this.prevUnquotedKey = key;
                if (!this.finished())
                    this.consume([" "]);
                result.set(key, value);
            }
            else if (this.positionalArgsParsed < this.positionalArgs.length && this.peek() !== "=") {
                // Parse [value] as the next positional arg
                const positionalKey = this.positionalArgs[this.positionalArgsParsed];
                this.positionalArgsParsed++;
                this.index = startIndex; // back up to reparse the key as a value
                const value = this.parseValue();
                if (["'", '"'].includes((_c = this.prev()) !== null && _c !== void 0 ? _c : ""))
                    this.prevUnquotedKey = undefined;
                else
                    this.prevUnquotedKey = key;
                if (!this.finished())
                    this.consume([" "]);
                if (result.has(positionalKey))
                    throw `Cannot assign ${value} to ${positionalKey} (positionally) since ${positionalKey} was already set to ${(_d = result.get(positionalKey)) !== null && _d !== void 0 ? _d : ""}`;
                result.set(positionalKey, value);
            }
            else {
                // Key not found; include a better error message if it is possible for quotes to have been missed
                if (this.prevUnquotedKey && this.peek() !== "=")
                    throw `Unknown argument: ${key} (if this should have been parsed as part of ${this.prevUnquotedKey}, you should surround the entire value in quotes)`;
                else
                    throw `Unknown argument: ${key}`;
            }
        }
        return result;
    }
    /**
     * @returns True if the entire command has been parsed.
     */
    finished() {
        return this.index >= this.command.length;
    }
    /**
     * @returns The next character to parse, if it exists.
     */
    peek() {
        if (this.index >= this.command.length)
            return undefined;
        return this.command.charAt(this.index);
    }
    /**
     * @returns The character just parsed, if it exists.
     */
    prev() {
        if (this.index <= 0)
            return undefined;
        if (this.index >= this.command.length + 1)
            return undefined;
        return this.command.charAt(this.index - 1);
    }
    /**
     * Advance the internal marker over the next expected character.
     * Throws an error on unexpected characters.
     *
     * @param allowed Characters that are expected.
     */
    consume(allowed) {
        var _a;
        if (this.finished())
            throw `Expected ${allowed}`;
        if (allowed.includes((_a = this.peek()) !== null && _a !== void 0 ? _a : "")) {
            this.index += 1;
        }
    }
    /**
     * Find the next occurance of one of the provided characters, or the end of
     * the string if the characters never appear again.
     *
     * @param searchValue The characters to locate.
     */
    findNext(searchValue) {
        let result = this.command.length;
        for (const value of searchValue) {
            const index = this.command.indexOf(value, this.index);
            if (index !== -1 && index < result)
                result = index;
        }
        return result;
    }
    /**
     * Starting from the internal marker, parse a single key.
     * This also advances the internal marker.
     *
     * @returns The next key.
     */
    parseKey() {
        const keyEnd = this.findNext(["=", " "]);
        const key = this.command.substring(this.index, keyEnd);
        this.index = keyEnd;
        return key;
    }
    /**
     * Starting from the internal marker, parse a single value.
     * This also advances the internal marker.
     *
     * Values are a single word or enclosed in matching quotes, i.e. one of:
     *    "[^"]*"
     *    '[^']*"
     *    [^'"][^ ]*
     *
     * @returns The next value.
     */
    parseValue() {
        var _a, _b;
        let valueEnder = " ";
        const quotes = ["'", '"'];
        if (quotes.includes((_a = this.peek()) !== null && _a !== void 0 ? _a : "")) {
            valueEnder = (_b = this.peek()) !== null && _b !== void 0 ? _b : ""; // The value is everything until the next quote
            this.consume([valueEnder]); // Consume opening quote
        }
        const valueEnd = this.findNext([valueEnder]);
        const value = this.command.substring(this.index, valueEnd);
        if (valueEnder !== " " && valueEnd === this.command.length) {
            throw `No closing ${valueEnder} found for ${valueEnder}${value}`;
        }
        // Consume the value (and closing quote)
        this.index = valueEnd;
        if (valueEnder !== " ")
            this.consume([valueEnder]);
        return value;
    }
}
