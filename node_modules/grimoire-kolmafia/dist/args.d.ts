import { Class, Effect, Familiar, Item, Location, Monster, Path, Skill } from "kolmafia";
/**
 * Specification for an argument that takes values in T.
 * @member key The key to use when parsing this argument.
 * @member help Description for the help text.
 * @member options An array of allowable values for this argument.
 *    Each entry has an optional description for the help text as well.
 * @member setting A setting to use for this argument. If not given,
 *    ${script name}_${argument name} is used; set to "" for no setting.
 *    A value in this setting is used as the new default for this argument,
 *    and can be overridden by a command line argument.
 * @member hidden If true, do not display this option in the help text.
 * @member default A default value to use if no value is provided.
 *    Note that 'default' is effectively optional, as all methods that take
 *    an ArgSpec allow for 'default' to be omitted. But it is typed as
 *    non-optional here to enable cool type inference voodoo.
 */
interface ArgSpec<T> {
    key?: Exclude<string, "help">;
    help?: string;
    options?: [T, string?][];
    setting?: string;
    hidden?: boolean;
    default: T;
}
/**
 * Allow the default argument to be optional, in a way that allows for cool type inference.
 */
declare type ArgSpecNoDefault<T> = Omit<ArgSpec<T>, "default">;
/**
 * Specification for an argument that takes values in T[].
 *
 * Entries are parsed by splitting on the separator and trimming.
 *
 * @member separator String to use as the separator between entries. If not
 *    given, defaults to ",".
 * @member noTrim If true, do not perform trimming on each entry.
 * @member default A default value to use if no value is provided.
 *    Note that 'default' is effectively optional, as all methods that take
 *    an ArraySpec allow for 'default' to be omitted. But it is typed as
 *    non-optional here to enable cool type inference voodoo.
 */
interface ArraySpec<T> extends ArgSpecNoDefault<T> {
    separator?: string;
    noTrim?: boolean;
    default: T[];
}
declare type ArraySpecNoDefault<T> = Omit<ArraySpec<T>, "default">;
interface ArgOptions {
    defaultGroupName?: string;
    positionalArgs?: string[];
}
export declare class Args {
    /**
     * Create an argument for a custom type.
     * @param spec Specification for this argument.
     * @param parser A function to parse a string value into the proper type.
     * @param valueHelpName The name of this type, for the help text.
     * @returns An argument.
     */
    static custom<T>(spec: ArgSpec<T>, parser: Parser<T>, valueHelpName: string): Arg<T>;
    static custom<T>(spec: ArgSpecNoDefault<T>, parser: Parser<T>, valueHelpName: string): ArgNoDefault<T>;
    /**
     * Create an array argument for a given type.
     * @param spec Specification for this argument.
     * @param argFromSpec A function to create a non-array version of this arg.
     * @returns An argument.
     */
    private static arrayFromArg;
    /**
     * Create a string argument.
     * @param spec Specification for this argument. See {@link ArgSpec} for details.
     */
    static string(spec: ArgSpec<string>): Arg<string>;
    static string(spec: ArgSpecNoDefault<string>): ArgNoDefault<string>;
    /**
     * Create a string[] argument.
     * @param spec Specification for this argument. See {@link ArraySpec} for details.
     */
    static strings(spec: ArraySpec<string>): Arg<string[]>;
    static strings(spec: ArraySpecNoDefault<string>): ArgNoDefault<string[]>;
    /**
     * Create a number argument.
     * @param spec Specification for this argument. See {@link ArgSpec} for details.
     */
    static number(spec: ArgSpec<number>): Arg<number>;
    static number(spec: ArgSpecNoDefault<number>): ArgNoDefault<number>;
    /**
     * Create a number[] argument.
     * @param spec Specification for this argument. See {@link ArraySpec} for details.
     */
    static numbers(spec: ArraySpec<number>): Arg<number[]>;
    static numbers(spec: ArraySpecNoDefault<number>): ArgNoDefault<number[]>;
    /**
     * Create a boolean argument.
     * @param spec Specification for this argument. See {@link ArgSpec} for details.
     */
    static boolean(spec: ArgSpec<boolean>): Arg<boolean>;
    static boolean(spec: ArgSpecNoDefault<boolean>): ArgNoDefault<boolean>;
    /**
     * Create a boolean[] argument.
     * @param spec Specification for this argument. See {@link ArraySpec} for details.
     */
    static booleans(spec: ArraySpec<boolean>): Arg<boolean[]>;
    static booleans(spec: ArraySpecNoDefault<boolean>): ArgNoDefault<boolean[]>;
    /**
     * Create a flag.
     * @param spec Specification for this argument. See {@link ArgSpec} for details.
     */
    static flag(spec: ArgSpec<boolean>): Arg<boolean>;
    static flag(spec: ArgSpecNoDefault<boolean>): ArgNoDefault<boolean>;
    /**
     * Create a class argument.
     * @param spec Specification for this argument. See {@link ArgSpec} for details.
     */
    static class(spec: ArgSpec<Class>): Arg<Class>;
    static class(spec: ArgSpecNoDefault<Class>): ArgNoDefault<Class>;
    /**
     * Create a Class[] argument.
     * @param spec Specification for this argument. See {@link ArraySpec} for details.
     */
    static classes(spec: ArraySpec<Class>): Arg<Class[]>;
    static classes(spec: ArraySpecNoDefault<Class>): ArgNoDefault<Class[]>;
    /**
     * Create an effect argument.
     * @param spec Specification for this argument. See {@link ArgSpec} for details.
     */
    static effect(spec: ArgSpec<Effect>): Arg<Effect>;
    static effect(spec: ArgSpecNoDefault<Effect>): ArgNoDefault<Effect>;
    /**
     * Create a Effect[] argument.
     * @param spec Specification for this argument. See {@link ArraySpec} for details.
     */
    static effects(spec: ArraySpec<Effect>): Arg<Effect[]>;
    static effects(spec: ArraySpecNoDefault<Effect>): ArgNoDefault<Effect[]>;
    /**
     * Create a familiar argument.
     * @param spec Specification for this argument. See {@link ArgSpec} for details.
     */
    static familiar(spec: ArgSpec<Familiar>): Arg<Familiar>;
    static familiar(spec: ArgSpecNoDefault<Familiar>): ArgNoDefault<Familiar>;
    /**
     * Create a Familiar[] argument.
     * @param spec Specification for this argument. See {@link ArraySpec} for details.
     */
    static familiars(spec: ArraySpec<Familiar>): Arg<Familiar[]>;
    static familiars(spec: ArraySpecNoDefault<Familiar>): ArgNoDefault<Familiar[]>;
    /**
     * Create an item argument.
     * @param spec Specification for this argument. See {@link ArgSpec} for details.
     */
    static item(spec: ArgSpec<Item>): Arg<Item>;
    static item(spec: ArgSpecNoDefault<Item>): ArgNoDefault<Item>;
    /**
     * Create a Item[] argument.
     * @param spec Specification for this argument. See {@link ArraySpec} for details.
     */
    static items(spec: ArraySpec<Item>): Arg<Item[]>;
    static items(spec: ArraySpecNoDefault<Item>): ArgNoDefault<Item[]>;
    /**
     * Create a location argument.
     * @param spec Specification for this argument. See {@link ArgSpec} for details.
     */
    static location(spec: ArgSpec<Location>): Arg<Location>;
    static location(spec: ArgSpecNoDefault<Location>): ArgNoDefault<Location>;
    /**
     * Create a Location[] argument.
     * @param spec Specification for this argument. See {@link ArraySpec} for details.
     */
    static locations(spec: ArraySpec<Location>): Arg<Location[]>;
    static locations(spec: ArraySpecNoDefault<Location>): ArgNoDefault<Location[]>;
    /**
     * Create a monster argument.
     * @param spec Specification for this argument. See {@link ArgSpec} for details.
     */
    static monster(spec: ArgSpec<Monster>): Arg<Monster>;
    static monster(spec: ArgSpecNoDefault<Monster>): ArgNoDefault<Monster>;
    /**
     * Create a Monster[] argument.
     * @param spec Specification for this argument. See {@link ArraySpec} for details.
     */
    static monsters(spec: ArraySpec<Monster>): Arg<Monster[]>;
    static monsters(spec: ArraySpecNoDefault<Monster>): ArgNoDefault<Monster[]>;
    /**
     * Create a path argument.
     * @param spec Specification for this argument. See {@link ArgSpec} for details.
     */
    static path(spec: ArgSpec<Path>): Arg<Path>;
    static path(spec: ArgSpecNoDefault<Path>): ArgNoDefault<Path>;
    /**
     * Create a Path[] argument.
     * @param spec Specification for this argument. See {@link ArraySpec} for details.
     */
    static paths(spec: ArraySpec<Path>): Arg<Path[]>;
    static paths(spec: ArraySpecNoDefault<Path>): ArgNoDefault<Path[]>;
    /**
     * Create a skill argument.
     * @param spec Specification for this argument. See {@link ArgSpec} for details.
     */
    static skill(spec: ArgSpec<Skill>): Arg<Skill>;
    static skill(spec: ArgSpecNoDefault<Skill>): ArgNoDefault<Skill>;
    /**
     * Create a Skill[] argument.
     * @param spec Specification for this argument. See {@link ArraySpec} for details.
     */
    static skills(spec: ArraySpec<Skill>): Arg<Skill[]>;
    static skills(spec: ArraySpecNoDefault<Skill>): ArgNoDefault<Skill[]>;
    /**
     * Create a group of arguments that will be printed separately in the help.
     *
     * Note that keys in the group must still be globally distinct.
     *
     * @param groupName The display name for the group in help.
     * @param args A JS object specifying the script arguments. Its values should
     *    be {@link Arg} objects (created by Args.string, Args.number, or others)
     *    or groups of arguments (created by Args.group).
     */
    static group<T extends ArgMap>(groupName: string, args: T): ArgGroup<T>;
    /**
     * Create a set of input arguments for a script.
     * @param scriptName Prefix for property names; often the name of the script.
     * @param scriptHelp Brief description of this script, for the help message.
     * @param args A JS object specifying the script arguments. Its values should
     *    be {@link Arg} objects (created by Args.string, Args.number, or others)
     *    or groups of arguments (created by Args.group).
     * @param options Config options for the args and arg parser.
     * @returns An object which can hold parsed argument values. The keys of this
     *    object are identical to the keys in 'args'.
     */
    static create<T extends ArgMap>(scriptName: string, scriptHelp: string, args: T, options?: ArgOptions): ParsedArgs<T> & {
        help: boolean;
    };
    /**
     * Parse the command line input into the provided script arguments.
     * @param args An object to hold the parsed argument values, from Args.create(*).
     * @param command The command line input.
     * @param includeSettings If true, parse values from settings as well.
     */
    static fill<T extends ArgMap>(args: ParsedArgs<T>, command: string | undefined, includeSettings?: boolean): void;
    /**
     * Parse command line input into a new set of script arguments.
     * @param scriptName Prefix to use in property names; typically the name of the script.
     * @param scriptHelp Brief description of this script, for the help message.
     * @param spec An object specifying the script arguments.
     * @param command The command line input.
     * @param options Config options for the args and arg parser.
     */
    static parse<T extends ArgMap>(scriptName: string, scriptHelp: string, spec: T, command: string, options?: ArgOptions): ParsedArgs<T>;
    /**
     * Print a description of the script arguments to the CLI.
     *
     * First, all top-level argument descriptions are printed in the order they
     * were defined. Afterwards, descriptions for groups of arguments are printed
     * in the order they were defined.
     *
     * @param args An object of parsed arguments, from Args.create(*).
     * @param maxOptionsToDisplay If given, do not list more than this many options for each arg.
     */
    static showHelp<T extends ArgMap>(args: ParsedArgs<T>, maxOptionsToDisplay?: number): void;
    /**
     * Load the metadata information for a set of arguments. Only for advanced usage.
     *
     * @param args A JS object specifying the script arguments. Its values should
     *    be {@link Arg} objects (created by Args.string, Args.number, or others)
     *    or groups of arguments (created by Args.group).
     * @returns A class containing metadata information.
     */
    static getMetadata<T extends ArgMap>(args: ParsedArgs<T>): WrappedArgMetadata<T>;
}
/**
 * A group of arguments.
 */
declare type ArgGroup<T extends ArgMap> = {
    name: string;
    args: T;
};
export declare class ParseError {
    message: string;
    constructor(message: string);
}
/**
 * A parser that can transform a string value into the desired type.
 * It may return undefined if given an invalid value.
 */
declare type Parser<T> = (value: string) => T | ParseError | undefined;
/**
 * An argument that takes values in T.
 * @member parser The parser to use to built T values.
 * @member valueHelpName The string name of T, e.g. NUMBER.
 */
interface Arg<T> extends Omit<ArgSpec<T>, "options"> {
    parser: Parser<T>;
    valueHelpName: string;
    options?: [string, string?][];
}
/**
 * Allow the default argument to be optional, in a way that allows for cool type inference.
 */
declare type ArgNoDefault<T> = Omit<Arg<T>, "default">;
/**
 * Metadata for the parsed arguments.
 *
 * This information is hidden within the parsed argument object so that it
 * is invisible to the user but available to fill(*) and showHelp(*).
 */
declare const specSymbol: unique symbol;
declare const scriptSymbol: unique symbol;
declare const scriptHelpSymbol: unique symbol;
declare const optionsSymbol: unique symbol;
declare type ArgMetadata<T extends ArgMap> = {
    [specSymbol]: T;
    [scriptSymbol]: string;
    [scriptHelpSymbol]: string;
    [optionsSymbol]: ArgOptions;
};
/**
 * Construct the object type for the parsed arguments with typescript voodoo.
 *
 * The keys for the parsed argument object match the keys from the argument
 * specifications. That is, for each (key: spec) pair in the argument spec
 * object, there is a (key: value) in the parsed argument object.
 *
 * If spec has type Arg<T> (i.e., has a default), then value has type T.
 * If spec has type ArgNoDefault<T>, the value has type T | undefined.
 *
 * Finally, there are hidden keys in ArgMetadata for fill(*) and showHelp(*).
 */
declare type ArgMap = {
    [key: string]: Arg<unknown> | ArgNoDefault<unknown> | ArgGroup<ArgMap>;
};
declare type ParsedGroup<T extends ArgMap> = {
    [k in keyof T]: T[k] extends ArgGroup<any> ? ParsedGroup<T[k]["args"]> : T[k] extends Arg<unknown> ? Exclude<ReturnType<T[k]["parser"]>, undefined | ParseError> : T[k] extends ArgNoDefault<unknown> ? Exclude<ReturnType<T[k]["parser"]>, ParseError> : never;
};
declare type ParsedArgs<T extends ArgMap> = ParsedGroup<T> & ArgMetadata<T>;
/**
 * A class that reveals the hidden metadata and specs for arguments.
 *
 * Only for advanced usage.
 */
declare class WrappedArgMetadata<T extends ArgMap> {
    spec: T;
    scriptName: string;
    scriptHelp: string;
    options: ArgOptions;
    constructor(args: ParsedArgs<T>);
    /**
     * Create a parsed args object from this spec using all default values.
     */
    loadDefaultValues(): ParsedGroup<T>;
    /**
     * Traverse the spec and possibly generate a value for each argument.
     *
     * @param result The object to hold the resulting argument values, typically
     *    the result of loadDefaultValues().
     * @param setTo A function to generate an argument value from each arg spec.
     *    If this function returns undefined, then the argument value is unchanged.
     */
    traverseAndMaybeSet(result: ParsedArgs<T>, setTo: <S>(keySpec: Arg<S> | ArgNoDefault<S>, key: string) => S | undefined): void;
    /**
     * Traverse the spec and call a method for each argument.
     *
     * @param process A function to call at each arg spec.
     */
    traverse(process: <S>(keySpec: Arg<S> | ArgNoDefault<S>, key: string) => void, onGroup?: <S extends ArgMap>(groupSpec: ArgGroup<S>, key: string) => void): void;
}
export {};
