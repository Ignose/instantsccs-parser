import { Familiar, Item, Slot } from "kolmafia";
import { Modes as LibramModes, Requirement } from "libram";
export declare const outfitSlots: readonly ["hat", "back", "weapon", "offhand", "shirt", "pants", "acc1", "acc2", "acc3", "famequip"];
export declare type OutfitSlot = (typeof outfitSlots)[number];
export declare type OutfitEquips = Partial<{
    [slot in OutfitSlot]: Item | Item[];
}>;
export declare const riderSlots: readonly ["buddy-bjorn", "crown-of-thrones"];
export declare type RiderSlot = (typeof riderSlots)[number];
export declare type OutfitRiders = Partial<{
    [slot in RiderSlot]: Familiar | Familiar[];
}>;
export declare type Equippable = Item | Familiar | OutfitSpec | Item[] | Outfit;
export interface OutfitSpec extends OutfitEquips {
    equip?: Item[];
    modes?: Modes;
    modifier?: string | string[];
    familiar?: Familiar;
    avoid?: Item[];
    skipDefaults?: boolean;
    riders?: OutfitRiders;
    bonuses?: Map<Item, number>;
    beforeDress?: (() => void)[];
    afterDress?: (() => void)[];
}
export declare type Modes = {
    backupcamera?: "ml" | "meat" | "init";
    umbrella?: "broken" | "forward-facing" | "bucket style" | "pitchfork style" | "constantly twirling" | "cocoon";
    snowsuit?: "eyebrows" | "smirk" | "nose" | "goatee" | "hat";
    edpiece?: "bear" | "owl" | "puma" | "hyena" | "mouse" | "weasel" | "fish";
    retrocape?: [
        "vampire" | "heck" | "robot" | undefined,
        "hold" | "thrill" | "kiss" | "kill" | undefined
    ];
    parka?: "kachungasaur" | "dilophosaur" | "ghostasaurus" | "spikolodon" | "pterodactyl";
    jillcandle?: "disco" | "ultraviolet" | "reading" | "red";
};
export declare class Outfit {
    equips: Map<Slot, Item>;
    riders: Map<Slot, Familiar>;
    modes: Modes;
    skipDefaults: boolean;
    familiar?: Familiar;
    modifier: string[];
    avoid: Item[];
    bonuses: Map<Item, number>;
    private postActions;
    private preActions;
    /**
     * Create an outfit from your current player state.
     */
    static current(): Outfit;
    /**
     * Check how many of an item is equipped on the outfit.
     */
    equippedAmount(item: Item): number;
    private isAvailable;
    /**
     * Check whether an item is equipped on the outfit, optionally in a specific slot.
     */
    haveEquipped(item: Item, slot?: Slot): boolean;
    private equipItemNone;
    private equipNonAccessory;
    private equipAccessory;
    private equipUsingDualWield;
    private getHoldingFamiliar;
    /**
     * Returns the bonus value associated with a given item.
     *
     * @param item The item to check the bonus of.
     * @returns The bonus assigned to that item.
     */
    getBonus(item: Item): number;
    /**
     * Applies a value to any existing bonus this item has, using a rule assigned by the `reducer` parameter
     *
     * @param item The item to try to apply a bonus to.
     * @param value The value to try to apply.
     * @param reducer Function that combines new and current bonus
     * @returns The total assigned bonus to that item.
     */
    applyBonus(item: Item, value: number, reducer: (a: number, b: number) => number): number;
    /**
     * Sets the bonus value of an item equal to a given value, overriding any current bonus assigned.
     *
     * @param item The item to try to apply a bonus to.
     * @param value The value to try to apply.
     * @returns The total assigned bonus to that item.
     */
    setBonus(item: Item, value: number): number;
    /**
     * Adds a value to any existing bonus this item has
     *
     * @param item The item to try to add a bonus to.
     * @param value The value to try to add.
     * @returns The total assigned bonus to that item.
     */
    addBonus(item: Item, value: number): number;
    /**
     * Apply the given items' bonuses to the outfit, using a rule given by the reducer
     *
     * @param items A map containing items and their bonuses
     * @param reducer A way of combining new bonuses with existing bonuses
     */
    applyBonuses(items: Map<Item, number>, reducer: (a: number, b: number) => number): void;
    /**
     * Sets the bonuses of the given items, overriding existing bonuses
     *
     * @param items Map containing items and bonuses
     */
    setBonuses(items: Map<Item, number>): void;
    /**
     * Adds the bonuses of the given items to any existing bonuses they ahave
     *
     * @param items Map containing items and bonuses
     */
    addBonuses(items: Map<Item, number>): void;
    private equipUsingFamiliar;
    private equipItem;
    private equipFamiliar;
    private equipSpec;
    /**
     * Equip the first thing that can be equipped to the outfit.
     *
     * @param things The things to equip.
     * @param slot The slot to equip them.
     * @returns True if one of the things is equipped, and false otherwise.
     */
    equipFirst(things: Item[] | Familiar[], slot?: Slot): boolean;
    /**
     * Equip a thing to the outfit.
     *
     * If no slot is given, then the thing will be equipped wherever possible
     * (possibly using dual-wielding, any of the accessory slots, or as
     * familiar equipment). If it is impossible to add this thing anywhere to
     * the outfit, this function will return false.
     *
     * If a slot is given, the item will be equipped only in that slot. If the
     * slot is filled with a different item, this function will return false.
     *
     * If the thing is already equipped in the provided slot, or if no slot is
     * given and the thing is already equipped in any slot, this function will
     * return true and not change the outfit.
     *
     * @param thing The thing or things to equip.
     * @param slot The slot to equip them.
     * @returns True if the thing was sucessfully equipped, and false otherwise.
     */
    equip(thing: Equippable, slot?: Slot): boolean;
    /**
     * Create a new outfit that confirms to a given spec. Return null if the outfit cannot be successfully created as such
     * @param spec The spec around which to build the outfit.
     * @param error An error to throw if we fail to equip the outfit; if this parameter is null, the return type will be Outfit | null
     * @returns A new outfit containing the inputted spec, or null if that is impossible.
     */
    static from(spec: OutfitSpec | Requirement): Outfit | null;
    static from(spec: OutfitSpec | Requirement, error: null): Outfit | null;
    static from(spec: OutfitSpec | Requirement, error: Error): Outfit;
    /**
     * Add a rider to the outfit.
     *
     * This function does *not* equip the corresponding item; it must be equipped separately.
     *
     * If a familiar is already specified as the rider that is different from the provided target, this function will return false and not change the rider.
     * @param target The familiar to use as the rider, or a ranked list of familiars to try to use as the rider.
     * @returns True if we successfully set the slot to a valid rider.
     */
    private equipRider;
    /**
     * Add a bjornified familiar to the outfit.
     *
     * This function does *not* equip the buddy bjorn itself; it must be equipped separately.
     *
     * If a familiar is already specified for the buddy bjorn that is different from the provided target, this function will return false and not change the buddy bjorn.
     * @param target The familiar to bjornify, or a ranked list of familiars to try to bjornify.
     * @returns True if we successfully set the bjorn to a valid target.
     */
    bjornify(target: Familiar | Familiar[]): boolean;
    /**
     * Add anenthroned familiar to the outfit.
     *
     * This function does *not* equip the crown of thrones itself; it must be equipped separately.
     *
     * If a familiar is already specified for the crown of thrones that is different from the provided target, this function will return false and not change the crown of thrones.
     * @param target The familiar to enthrone, or a ranked list of familiars to try to enthrone.
     * @returns True if we successfully set the enthrone to a valid target.
     */
    enthrone(target: Familiar | Familiar[]): boolean;
    /**
     * Set the provided modes for items that may be equipped in the outfit.
     *
     * This function does *not* equip items for the set modes; they must be
     * equipped separately.
     *
     * If a mode is already set for an item that is different from the provided
     * mode, this function will return false and not change the mode for that
     * item. (But other modes might still be changed if they are compatible.)
     *
     * Note that the superhero and instuctions of a retrocape can be set
     * independently (`undefined` is treated as "don't care").
     *
     * @param modes Modes to set in this outfit.
     * @returns True if all modes were sucessfully set, and false otherwise.
     */
    setModes(modes: Modes): boolean;
    /**
     * Check if it is possible to equip a thing to this outfit using .equip().
     *
     * This does not change the current outfit.
     *
     * @param thing The thing to equip.
     * @param slot The slot to equip them.
     * @returns True if this thing can be equipped.
     */
    canEquip(thing: Equippable, slot?: Slot): boolean;
    /**
     * Check if it is possible to equip a thing to this outfit using .equip(); if it is, do so.
     *
     * This does change the current outfit.
     * @param thing The thing to equip.
     * @param slot The slot to equip them.
     * @returns True if this thing was successfully equipped.
     */
    tryEquip(thing: Equippable, slot?: Slot): boolean;
    afterDress(...actions: (() => void)[]): void;
    beforeDress(...actions: (() => void)[]): void;
    /**
     * Equip this outfit.
     */
    private _dress;
    dress(): void;
    /**
     * Build an Outfit identical to this outfit.
     */
    clone(): Outfit;
    /**
     * Build an OutfitSpec identical to this outfit.
     */
    spec(): OutfitSpec;
}
/**
 * Get the modes of this outfit in a type compatible with Libram.
 *
 * This conversion is needed since we store the retrocape modes
 * internally as an array, but libram uses a string.
 *
 * @returns The modes equipped to this outfit.
 */
export declare function convertToLibramModes(modes: Modes): LibramModes & Record<keyof LibramModes, unknown>;
export declare function convertFromLibramModes(modes: LibramModes): Modes;
/**
 * Get the current modes of all items.
 *
 * @returns The current mode settings for all items, equipped or not.
 */
export declare function getCurrentModes(): Modes & Record<keyof Modes, unknown>;
