import { Task } from "./task";
import { EnvironmentType, PropertiesManager } from "libram";
import { Location } from "kolmafia";
import { Outfit } from "./outfit";
import { ActionDefaults, CombatResources, CombatStrategy } from "./combat";
declare type Optional<T> = {
    [x in keyof T]-?: undefined extends T[x] ? NonNullable<T[x]> : never;
};
export declare class EngineOptions<A extends string = never, Context = void, T extends Task<A, Context> = Task<A, Context>> {
    combat_defaults?: ActionDefaults<A>;
    ccs?: string;
    allow_partial_outfits?: boolean;
    default_task_options?: Partial<Optional<T>>;
}
/**
 * An Engine which allows for custom engine state. Most beginning users should
 * use the Engine class instead.
 */
export declare abstract class ContextualEngine<A extends string = never, Context = void, T extends Task<A, Context> = Task<A, Context>> {
    tasks: T[];
    options: EngineOptions<A, T>;
    attempts: {
        [task_name: string]: number;
    };
    propertyManager: PropertiesManager;
    tasks_by_name: Map<string, T>;
    cachedCcsContents: string;
    /**
     * Create the engine.
     * @param tasks A list of tasks for looking up task dependencies.
     * @param options Basic configuration of the engine.
     */
    constructor(tasks: T[], options?: EngineOptions<A, T>);
    /**
     * Compute the current engine state, to be passed to task functions.
     *
     * This will be called extremely often (once each for every time a method
     * is called on a task), so the lifecycle of expensive computations (like
     * visitUrl calls) should be handled carefully and separately.
     */
    abstract getContext(task: T): Context;
    /**
     * Determine the next task to perform.
     * By default, this is the first task in the task list that is available.
     * @returns The next task to perform, or undefined if no tasks are available.
     */
    getNextTask(): T | undefined;
    /**
     * Continually get the next task and execute it.
     * @param actions If given, only perform up to this many tasks.
     */
    run(actions?: number): void;
    /**
     * Close the engine and reset all properties.
     * After this has been called, this object should not be used.
     */
    destruct(): void;
    /**
     * Check if the given task is available at this moment.
     * @param task: The task to check.
     * @returns true if all dependencies are complete and the task is ready.
     *  Note that dependencies are not checked transitively. That is, if
     *  A depends on B which depends on C, then A is ready if B is complete
     *  (regardless of if C is complete or not).
     */
    available(task: T): boolean;
    /**
     * Perform all steps to execute the provided task.
     * This is the main entry point for the Engine.
     * @param task The current executing task.
     */
    execute(task: T): void;
    /**
     * Print a message to indicate the task has begun.
     * @param task The current executing task.
     */
    printExecutingMessage(task: T): void;
    /**
     * Acquire all items for the task.
     * @param task The current executing task.
     */
    acquireItems(task: T): void;
    /**
     * Acquire all effects for the task.
     * @param task The current executing task.
     */
    acquireEffects(task: T): void;
    /**
     * Create an outfit for the task with all required equipment.
     * @param task The current executing task.
     */
    createOutfit(task: T): Outfit;
    /**
     * Equip the outfit for the task.
     * @param task The current executing task.
     * @param outfit The outfit for the task, possibly augmented by the engine.
     */
    dress(task: T, outfit: Outfit): void;
    /**
     * Perform any engine-specific customization for the outfit and combat plan.
     *
     * This is a natural method to override in order to:
     *   * Enable the use of any resources in the outfit or combat (e.g., allocate banishers).
     *   * Equip a default outfit.
     *   * Determine additional monster macros at a global level (e.g., use flyers).
     * @param task The current executing task.
     * @param outfit The outfit for the task.
     * @param combat The combat strategy so far for the task.
     * @param resources The combat resources assigned so far for the task.
     */
    customize(task: T, outfit: Outfit, combat: CombatStrategy<A, Context>, resources: CombatResources<A, Context>): void;
    /**
     * Set the choice settings for the task.
     * @param task The current executing task.
     * @param manager The property manager to use.
     */
    setChoices(task: T, manager: PropertiesManager): void;
    /**
     * Save the combat macro for this task.
     * @param task The current executing task.
     * @param task_combat The completed combat strategy far for the task.
     * @param task_resources The combat resources assigned for the task.
     */
    setCombat(task: T, task_combat: CombatStrategy<A, Context>, task_resources: CombatResources<A, Context>): void;
    /**
     * Do any task-specific preparation.
     * @param task The current executing task.
     */
    prepare(task: T): void;
    /**
     * Actually perform the task.
     * @param task The current executing task.
     */
    do(task: T): void;
    /**
     * Check if the task.do should be immediately repeated without any prep.
     *
     * By default, this is only used to repeat a task if we hit one of:
     *   1. Halloweener dog noncombats,
     *   2. June cleaver noncombats,
     *   3. Lil' Doctor™ bag noncombat, or
     *   4. Turtle taming noncombats.
     * @param task The current executing task.
     * @returns True if the task should be immediately repeated.
     */
    shouldRepeatAdv(task: T): boolean;
    /**
     * Do any task-specific wrapup activities.
     * @param task The current executing task.
     */
    post(task: T): void;
    /**
     * Mark that an attempt was made on the current task.
     * @param task The current executing task.
     */
    markAttempt(task: T): void;
    /**
     * Check if the task has passed any of its internal limits.
     * @param task The task to check.
     * @param postcondition The postcondition from the task guard.
     * @throws An error if any of the internal limits have been passed.
     */
    checkLimits(task: T, postcondition: (() => boolean) | undefined): void;
    static defaultSettings: {
        logPreferenceChange: boolean;
        logPreferenceChangeFilter: string;
        battleAction: string;
        autoSatisfyWithMall: boolean;
        autoSatisfyWithNPCs: boolean;
        autoSatisfyWithCoinmasters: boolean;
        autoSatisfyWithStash: boolean;
        dontStopForCounters: boolean;
        maximizerFoldables: boolean;
        hpAutoRecovery: string;
        hpAutoRecoveryTarget: string;
        mpAutoRecovery: string;
        mpAutoRecoveryTarget: string;
        afterAdventureScript: string;
        betweenBattleScript: string;
        choiceAdventureScript: string;
        familiarScript: string;
        currentMood: string;
        autoTuxedo: boolean;
        autoPinkyRing: boolean;
        autoGarish: boolean;
        allowNonMoodBurning: boolean;
        allowSummonBurning: boolean;
        libramSkillsSoftcore: string;
    };
    private getDefaultSettings;
    /**
     * Initialize properties for the script.
     * @param manager The properties manager to use.
     */
    initPropertiesManager(manager: PropertiesManager): void;
}
export declare class Engine<A extends string = never, T extends Task<A, void> = Task<A, void>> extends ContextualEngine<A, void, T> {
    getContext(task: T): void;
}
export declare function maxSongs(): number;
export declare const wanderingNCs: Set<string>;
export declare const environmentSpecificNCs: Map<string, EnvironmentType>;
export declare const zoneSpecificNCs: Map<string, Location[]>;
/**
 * Return true if the last adv was one of:
 *   1. Halloweener dog noncombats,
 *   2. June cleaver noncombats,
 *   3. Lil' Doctor™ bag noncombat, or
 *   4. Turtle taming noncombats.
 */
export declare function lastEncounterWasWanderingNC(): boolean;
export {};
